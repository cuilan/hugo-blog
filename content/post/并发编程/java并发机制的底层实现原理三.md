---
title: Java并发机制的底层实现原理（原子操作）
date: 2019-04-01 22:29:11
tags:
- Java
- 并发
- 多线程
categories:
- 并发编程
---

原子操作：不可被中断的一个或一系列操作。

## 一、处理器如何实现原子操作

### 使用总线锁保证原子性

**第一个机制是通过总线锁保证原子性**。如果多个处理器同时对共享变量进行读改写操作（i++就是经典的读改写操作），那么共享变量就会被多个处理器同时进行操作，这样的操作就不是原子的。

要想保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。

处理器使用 **总线锁** 来解决这个问题。

**总线锁**：就是使用处理器通过的一个 **LOCK #** 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。

<!-- more -->

### 使用缓存锁保证原子性

**第二个机制是通过缓存锁定来保证原子性**。在同一时刻，只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这期间其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大。

**缓存锁定**：指内存区域如果被缓存在处理器的缓存行中，并且在 Lock 操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言 LOCK # 信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性。因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写到已被锁定的缓存行的数据时，会使缓存无效。

**但是有两种情况下处理器不会使用缓存锁定**：
 - 当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线锁定。
 - 有些处理器不支持缓存锁定。

* * *

## 二、Java如何实现原子操作

在Java中可以通过 **锁** 和 **循环CAS** 的方式来实现原子操作。

### 使用循环CAS实现原子操作

从Java1.5开始，JDK的并发包提供了一些类来支持原子操作：
 - **AtomicBoolean**: 用原子方式更新boolean值
 - **AtomicInteger**: 用原子方式更新int值
 - **AtomicLong**: 用原子方式更新long值
 - ......

### CAS实现原子操作的三大问题

 - **ABA问题**：JDK的 **Atomic包** 里 **AtomicStampedReference** 来解决ABA问题。
 - **循环时间长开销大**
 - **只能保证一个共享变量的原子操作**：**AtomicReference** 来保证引用对象之间的原子性，把多个变量放在一个对象里进行CAS操作。

### 使用锁机制实现原子性

锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了多种锁机制，有**偏向锁**、**轻量级锁**和**互斥锁**。**_除了偏向锁，JVM实现锁的方式都用了循环CAS_**。即当一个线程想进入同步块的时候使用循环CAS的方式来获得锁，当它想退出同步块的时候使用循环CAS释放锁。
