---
layout:     post 
title:      "对象在内存中流转过程(栈上分配、TLAB)"
subtitle:   "栈上分配、TLAB、Eden"
description: "一般在java程序中，new的对象是分配在堆空间中的，但是实际的情况是，大部分的new对象会进入堆空间中，而并非是全部的对象，还有另外两个地方可以存储new的对象，我们称之为栈上分配以及TLAB。"
date:       2021-03-24
author:     "张岩"
published: true
tags:
    - Java
    - 虚拟机
categories: [ Java ]
---

# 一、栈上分配

## 为什么需要栈上分配？

在 Java 程序中，有很多对象的作用域都不会逃逸出方法外，也就是说该对象的生命周期会随着方法的调用开始而开始，方法的调用结束而结束，对于此类对象，可以考虑不在堆上进行分配。

因为一旦分配在堆空间中，当方法调用结束，没有引用指向该对象，该对象就需要被 gc 回收，而如果存在大量的这种情况，对 gc 来说无疑是一种负担。

## 什么是栈上分配？

JVM 提供了一种叫做 **栈上分配** 的概念，针对那些作用域不会逃逸出方法的对象，在分配内存时不在将对象分配在堆内存中，而是将对象属性打散后分配在栈上（**线程私有**，属于栈内存）。这样，随着方法的调用结束，栈空间的回收就会随着将栈上分配的打散后的对象回收掉，不再给 gc 增加额外的无用负担，从而提升应用程序整体的性能。

## 栈上分配如何开启？

栈上分配需要有一定的前提

* **开启逃逸分析** (**`-XX:+DoEscapeAnalysis`**)

逃逸分析的作用：分析对象的作用域是否会逃逸出方法之外，在 server 虚拟机模式下才可以开启（jdk1.6默认开启）。

* **开启标量替换** (**`-XX:+EliminateAllocations`**)

标量替换的作用是允许将对象根据属性打散后分配再栈上，默认该配置为开启。

如何查看逃逸分析的筛选结果

* **开启打印逃逸分析筛选结果** (**`-XX:+PrintEscapeAnalysis`**)

---

# 二、TLAB

## 为什么需要TLAB？

我们知道，对象分配在堆上，而堆是一个全局共享的区域，当多个线程同一时刻操作堆内存分配对象空间时，就需要进行同步，而同步带来的效果就是对象分配效率变差（尽管JVM采用了CAS的形式处理分配失败的情况），但是对于存在竞争激烈的分配场合仍然会导致效率变差。

## 什么是TLAB？

**Thread Local Allocation Buffer 线程本地分配缓存**

那么能不能构造一种线程私有的堆空间，哪怕这块堆空间特别小，但是只要有，就可以每个线程在分配对象到堆空间时，先分配到自己所属的那一块堆空间中，避免同步带来的效率问题，从而提高分配效率

## 开启TLAB

* **开启 TLAB 功能** (**`-XX: +UseTLAB`**)（默认开启）。

* **打开跟踪 TLAB 的使用情况** (**`-XX:+PrintTLAB`**)

* **调整 TLAB 默认大小** (**`-XX:TLABSize`**)

## 总结

需要 TLAB 的原因就是提高对象在堆上的分配效率而采用的一种手段，就是给每个线程分配一小块私有的堆空间，即：**TLAB 是一块线程私有的堆空间（实际上是Eden区中划出的）**。

---

# 三、栈上分配和TLAB对比

| 名称 | 针对点 | 处于对象分配流程的位置 |
| :---: | :---: | :---: |
| 栈上分配 | 避免GC无谓的负担 | 1 |
| TLAB | 加速堆上对象的分配 | 2 |



