[{"author":null,"categories":null,"content":"Let the cat out of the bag.","date":1599177600,"description":"Let the cat out of the bag.","dir":"/","excerpt_html":"Let the cat out of the bag.","excerpt_text":"Let the cat out of the bag.","expirydate":-62135596800,"fuzzywordcount":100,"html":"Let the cat out of the bag.","keywords":null,"kind":"home","lang":"en","lastmod":1599177600,"objectID":"3976528693a0108357f4928017600865","permalink":"https://cuilan.github.io/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/","section":"","summary":"Welcome to my blog with some of my work in progress. I\u0026rsquo;ve been working on this book idea. You can read some of the chapters below.","tags":null,"title":"CUILAN","type":"page","url":"/","weight":0,"wordcount":26},{"author":null,"categories":null,"content":null,"date":1599177600,"description":"","dir":"post/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1599177600,"objectID":"abc931e99d57d2fd1a465e7df785c046","permalink":"https://cuilan.github.io/2020/09/04/hello-world/","publishdate":"2020-09-04T00:00:00Z","readingtime":1,"relpermalink":"/2020/09/04/hello-world/","section":"post","summary":"“Yeah It\u0026rsquo;s on. ” Hello World!","tags":null,"title":"Welcome to Zhaohuabing Blog","type":"post","url":"/2020/09/04/hello-world/","weight":0,"wordcount":10},{"author":null,"categories":null,"content":null,"date":1583168400,"description":"","dir":"post/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"section","lang":"en","lastmod":1583168400,"objectID":"6370009740e1eb2ee0b7974f10ecc91f","permalink":"https://cuilan.github.io/post/","publishdate":"2020-03-02T12:00:00-05:00","readingtime":1,"relpermalink":"/post/","section":"post","summary":"Articles are paginated with only three posts here for example. You can set the number of entries to show on this page with the \u0026ldquo;pagination\u0026rdquo; setting in the config file.","tags":null,"title":"Articles","type":"post","url":"/post/","weight":0,"wordcount":30},{"author":null,"categories":["SPRING"],"content":null,"date":1573743600,"description":"","dir":"post/spring/SpringMVC/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1573743600,"objectID":"29d7390dd46979933e801ae63876080a","permalink":"https://cuilan.github.io/post/spring/springmvc/springmvc-03/","publishdate":"2019-11-14T15:00:00Z","readingtime":0,"relpermalink":"/post/spring/springmvc/springmvc-03/","section":"post","summary":"","tags":["Java","源码","SpringMVC"],"title":"3.SpringMVC的请求如何分发？","type":"post","url":"/post/spring/springmvc/springmvc-03/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1573743600,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"taxonomy","lang":"en","lastmod":1573743600,"objectID":"","permalink":"https://cuilan.github.io/categories/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/categories/","section":"categories","summary":"","tags":null,"title":"Categories","type":"categories","url":"/categories/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1573743600,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1573743600,"objectID":"","permalink":"https://cuilan.github.io/tags/java/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/java/","section":"tags","summary":"","tags":null,"title":"Java","type":"tags","url":"/tags/java/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1573743600,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1573743600,"objectID":"","permalink":"https://cuilan.github.io/categories/spring/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/categories/spring/","section":"categories","summary":"","tags":null,"title":"SPRING","type":"categories","url":"/categories/spring/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1573743600,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1573743600,"objectID":"","permalink":"https://cuilan.github.io/tags/springmvc/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/springmvc/","section":"tags","summary":"","tags":null,"title":"SpringMVC","type":"tags","url":"/tags/springmvc/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1573743600,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"taxonomy","lang":"en","lastmod":1573743600,"objectID":"","permalink":"https://cuilan.github.io/tags/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/","section":"tags","summary":"","tags":null,"title":"Tags","type":"tags","url":"/tags/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1573743600,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1573743600,"objectID":"","permalink":"https://cuilan.github.io/tags/%E6%BA%90%E7%A0%81/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/%E6%BA%90%E7%A0%81/","section":"tags","summary":"","tags":null,"title":"源码","type":"tags","url":"/tags/%E6%BA%90%E7%A0%81/","weight":0,"wordcount":0},{"author":null,"categories":["SPRING"],"content":null,"date":1572879600,"description":"","dir":"post/spring/SpringMVC/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":2700,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1572879600,"objectID":"810b5280c0e6b659e64e500c9160163d","permalink":"https://cuilan.github.io/post/spring/springmvc/springmvc-02/","publishdate":"2019-11-04T15:00:00Z","readingtime":6,"relpermalink":"/post/spring/springmvc/springmvc-02/","section":"post","summary":"一、SpringMVC入口 SpringMVC启动类为：org.springframework.web.servlet.DispatcherS","tags":["Java","源码","SpringMVC"],"title":"2.SpringMVC核心分发器DispatcherServlet分析","type":"post","url":"/post/spring/springmvc/springmvc-02/","weight":0,"wordcount":2633},{"author":null,"categories":["SPRING"],"content":null,"date":1572436800,"description":"","dir":"post/spring/SpringMVC/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":300,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1572436800,"objectID":"129d2836ce872a0ac1541a50d8d0d2b3","permalink":"https://cuilan.github.io/post/spring/springmvc/springmvc-01/","publishdate":"2019-10-30T12:00:00Z","readingtime":1,"relpermalink":"/post/spring/springmvc/springmvc-01/","section":"post","summary":"SpringMVC项目的演示示例，包含 maven 依赖配置，web.xml 文件配置，spring-mvc.xml 文件配置等，代码部分省略。 创建mave","tags":["Java","源码","SpringMVC"],"title":"1.SpringMVC使用示例","type":"post","url":"/post/spring/springmvc/springmvc-01/","weight":0,"wordcount":283},{"author":null,"categories":["SPRING"],"content":null,"date":1572350400,"description":"","dir":"post/spring/SpringMVC/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1572350400,"objectID":"3d6bd1e258d79b33e14bb1d95ad437c6","permalink":"https://cuilan.github.io/post/spring/springmvc/springmvc/","publishdate":"2019-10-29T12:00:00Z","readingtime":1,"relpermalink":"/post/spring/springmvc/springmvc/","section":"post","summary":"目录 1.SpringMVC使用示例 2.SpringMVC核心分发器DispatcherServlet分析 3.SpringMVC的请求如何分发","tags":["Java","源码","SpringMVC","目录"],"title":"SpringMVC目录","type":"post","url":"/post/spring/springmvc/springmvc/","weight":0,"wordcount":70},{"author":null,"categories":null,"content":null,"date":1572350400,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1572350400,"objectID":"","permalink":"https://cuilan.github.io/tags/%E7%9B%AE%E5%BD%95/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/%E7%9B%AE%E5%BD%95/","section":"tags","summary":"","tags":null,"title":"目录","type":"tags","url":"/tags/%E7%9B%AE%E5%BD%95/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1571238000,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1571238000,"objectID":"","permalink":"https://cuilan.github.io/tags/go/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/go/","section":"tags","summary":"","tags":null,"title":"Go","type":"tags","url":"/tags/go/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1571238000,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1571238000,"objectID":"","permalink":"https://cuilan.github.io/categories/golang/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/categories/golang/","section":"categories","summary":"","tags":null,"title":"GOLANG","type":"categories","url":"/categories/golang/","weight":0,"wordcount":0},{"author":null,"categories":["GOLANG"],"content":null,"date":1571238000,"description":"","dir":"post/go/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":300,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1571238000,"objectID":"ea946f90f01fd5ac3c4792f18df56bb1","permalink":"https://cuilan.github.io/post/go/go%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","publishdate":"2019-10-16T15:00:00Z","readingtime":1,"relpermalink":"/post/go/go%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","section":"post","summary":"Go开发环境 下载并安装Go开发包 Go语言开发包：https://golang.org/ 安装并配置环境变量 # go语言安装路径 GOROOT=C:\\Go\\ # 修改gopat","tags":["Go"],"title":"Go环境搭建","type":"post","url":"/post/go/go%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","weight":0,"wordcount":232},{"author":null,"categories":["并发编程"],"content":null,"date":1568894400,"description":"","dir":"post/并发编程/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1200,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1568894400,"objectID":"6f589a54137d612889003535aba82e5d","permalink":"https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E4%B8%AD%E7%9A%84%E9%94%81%E4%BA%8C/","publishdate":"2019-09-19T12:00:00Z","readingtime":3,"relpermalink":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E4%B8%AD%E7%9A%84%E9%94%81%E4%BA%8C/","section":"post","summary":"AbstractQueuedSynchronizer 同步器提供了一个框架，用于构建 先进先出(FIFO) 等待队列的 阻塞锁 和 相关同步器（信号量，事件等）。它使用了一个 int 成员变量表示同步状态，通过","tags":["Java","并发","多线程"],"title":"Java中的锁-AbstractQueuedSynchronizer队列同步器","type":"post","url":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E4%B8%AD%E7%9A%84%E9%94%81%E4%BA%8C/","weight":0,"wordcount":1192},{"author":null,"categories":null,"content":null,"date":1568894400,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1568894400,"objectID":"","permalink":"https://cuilan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","section":"tags","summary":"","tags":null,"title":"多线程","type":"tags","url":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1568894400,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1568894400,"objectID":"","permalink":"https://cuilan.github.io/tags/%E5%B9%B6%E5%8F%91/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/%E5%B9%B6%E5%8F%91/","section":"tags","summary":"","tags":null,"title":"并发","type":"tags","url":"/tags/%E5%B9%B6%E5%8F%91/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1568894400,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1568894400,"objectID":"","permalink":"https://cuilan.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","section":"categories","summary":"","tags":null,"title":"并发编程","type":"categories","url":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","weight":0,"wordcount":0},{"author":null,"categories":["并发编程"],"content":null,"date":1568761200,"description":"","dir":"post/并发编程/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":300,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1568761200,"objectID":"c77f43dbfeed7d32e1daea4460c0e967","permalink":"https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9B%AE%E5%BD%95/","publishdate":"2019-09-17T23:00:00Z","readingtime":1,"relpermalink":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9B%AE%E5%BD%95/","section":"post","summary":"目录 Java并发解决方案 Java并发机制的底层实现原理（volatile） Java并发机制的底层实现原理（synchronized） Java","tags":["Java","并发","多线程","目录"],"title":"Java并发编程目录","type":"post","url":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9B%AE%E5%BD%95/","weight":0,"wordcount":207},{"author":null,"categories":["JAVA"],"content":null,"date":1568736000,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":300,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1568736000,"objectID":"15ad8b41af9971e97730f050ea8e151f","permalink":"https://cuilan.github.io/post/java/dictionary-source-analysis/","publishdate":"2019-09-17T16:00:00Z","readingtime":1,"relpermalink":"/post/java/dictionary-source-analysis/","section":"post","summary":"一、Dictionary特点或规范 Dictionary 抽象类形式上等同于一个接口，其全部方法都是抽象方法。它是 Hashtable 的父类，它将 键 映射到 值。每个键和每个值都是一个","tags":["Java","源码","集合框架"],"title":"Dictionary抽象类源码分析","type":"post","url":"/post/java/dictionary-source-analysis/","weight":0,"wordcount":221},{"author":null,"categories":null,"content":null,"date":1568736000,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1568736000,"objectID":"","permalink":"https://cuilan.github.io/categories/java/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/categories/java/","section":"categories","summary":"","tags":null,"title":"JAVA","type":"categories","url":"/categories/java/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1568736000,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1568736000,"objectID":"","permalink":"https://cuilan.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/","section":"tags","summary":"","tags":null,"title":"集合框架","type":"tags","url":"/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/","weight":0,"wordcount":0},{"author":null,"categories":["JAVA"],"content":null,"date":1568721600,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":900,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1568721600,"objectID":"0c2a19468d2f128479c10e85562a5192","permalink":"https://cuilan.github.io/post/java/treemap-source-analysis/","publishdate":"2019-09-17T12:00:00Z","readingtime":2,"relpermalink":"/post/java/treemap-source-analysis/","section":"post","summary":"java.util.TreeMap 类继承了 java.util.AbstractMap 抽象类，实现了 java.util.NavigableMap、java.lang.Cloneable、java.io.Serial","tags":["Java","源码","集合框架"],"title":"TreeMap源码分析","type":"post","url":"/post/java/treemap-source-analysis/","weight":0,"wordcount":881},{"author":null,"categories":["JAVA"],"content":null,"date":1568509200,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1700,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1568509200,"objectID":"0f84c54c9ed7ecef77781528257b9081","permalink":"https://cuilan.github.io/post/java/linkedhashmap-source-analysis/","publishdate":"2019-09-15T01:00:00Z","readingtime":4,"relpermalink":"/post/java/linkedhashmap-source-analysis/","section":"post","summary":"java.util.LinkedHashMap 类继承了 java.util.HashMap 类，实现了 java.util.Map 接口。 LinkedHashMap继承关系 一、LinkedHashMap特点或规范 1.1 特点 java.util.LinkedHashMap 是 java.util.Map 接口的 链表 + 哈希 实现，具","tags":["Java","源码","集合框架"],"title":"LinkedHashMap源码分析","type":"post","url":"/post/java/linkedhashmap-source-analysis/","weight":0,"wordcount":1613},{"author":null,"categories":["JAVA"],"content":null,"date":1568221200,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":2600,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1568221200,"objectID":"f178c78a24ada3dce21a4312f0aa65c3","permalink":"https://cuilan.github.io/post/java/hashmap-treenode/","publishdate":"2019-09-11T17:00:00Z","readingtime":6,"relpermalink":"/post/java/hashmap-treenode/","section":"post","summary":"继承关系： java.util.Map.Entry Map 接口中的顶层实体接口。 java.util.HashMap.Node HashMap 中的单向链表节点。 java.util.LinkedHashMap.Entry LinkedHashMap 中的双向链表节点。 java.util.HashMap.TreeNode HashMap 中的红黑树节点。 TreeNode继承关系 一、HashMa","tags":["Java","源码","集合框架"],"title":"HashMap.TreeNode类源码分析","type":"post","url":"/post/java/hashmap-treenode/","weight":0,"wordcount":2589},{"author":null,"categories":["JAVA"],"content":null,"date":1567530000,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":6300,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1567530000,"objectID":"e60d48719f0d9626e7382405a26c90bb","permalink":"https://cuilan.github.io/post/java/hashmap-source-analysis/","publishdate":"2019-09-03T17:00:00Z","readingtime":13,"relpermalink":"/post/java/hashmap-source-analysis/","section":"post","summary":"java.util.HashMap 类继承了 java.util.AbstractMap 抽象类，实现了 java.util.Map、java.lang.Cloneable、java.io.Serializable 接口。","tags":["Java","源码","集合框架"],"title":"HashMap源码分析","type":"post","url":"/post/java/hashmap-source-analysis/","weight":0,"wordcount":6207},{"author":null,"categories":["JAVA"],"content":null,"date":1567443600,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1900,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1567443600,"objectID":"8a8c5178d5d95a612c27381efd82a422","permalink":"https://cuilan.github.io/post/java/abstractmap-source-analysis/","publishdate":"2019-09-02T17:00:00Z","readingtime":4,"relpermalink":"/post/java/abstractmap-source-analysis/","section":"post","summary":"java.util.AbstractMap 抽象类实现了 java.util.Map 接口。 AbstractMap接口继承关系 一、AbstractMap特点或规范 AbstractMap 抽象类提供了 Map 接口的基础实现，以最大限度地减少","tags":["Java","源码","集合框架"],"title":"AbstractMap源码分析","type":"post","url":"/post/java/abstractmap-source-analysis/","weight":0,"wordcount":1802},{"author":null,"categories":["JAVA"],"content":null,"date":1567011600,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":600,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1567011600,"objectID":"222a3fc263b81277287532edd0c0dbd1","permalink":"https://cuilan.github.io/post/java/navigablemap-source-analysis/","publishdate":"2019-08-28T17:00:00Z","readingtime":2,"relpermalink":"/post/java/navigablemap-source-analysis/","section":"post","summary":"java.util.NavigableMap 接口直接继承自 java.util.SortedMap 接口。 NavigableMap接口继承关系 一、NavigableMap特点或规范 NavigableMap 使用可导航的方法扩展了 SortedMap","tags":["Java","源码","集合框架"],"title":"NavigableMap接口源码分析","type":"post","url":"/post/java/navigablemap-source-analysis/","weight":0,"wordcount":563},{"author":null,"categories":["JAVA"],"content":null,"date":1566946800,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1000,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1566946800,"objectID":"dd137f4bf25b4b02befddd5c6c05905f","permalink":"https://cuilan.github.io/post/java/sortedmap-source-analysis/","publishdate":"2019-08-27T23:00:00Z","readingtime":2,"relpermalink":"/post/java/sortedmap-source-analysis/","section":"post","summary":"java.util.SortedMap 接口直接继承自 java.util.Map 接口。 SortedMap接口继承关系 一、SortedMap特点或规范 SortedMap 在 Map 的基础上进一步提供其 key 的总排序。 SortedMap 默认是根据其 key","tags":["Java","源码","集合框架"],"title":"SortedMap接口源码分析","type":"post","url":"/post/java/sortedmap-source-analysis/","weight":0,"wordcount":976},{"author":null,"categories":["JAVA"],"content":null,"date":1566399600,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":2600,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1566399600,"objectID":"446091bc9d2d3856ba87f10f0ae9f03a","permalink":"https://cuilan.github.io/post/java/map-source-analysis/","publishdate":"2019-08-21T15:00:00Z","readingtime":6,"relpermalink":"/post/java/map-source-analysis/","section":"post","summary":"java.util.Map 接口是双列集合的顶级接口。 一、Map特点或规范 双列集合，由 key 映射 value 的对象。 Map 不能包含重复的 key，且每个 key 只能映射一个 value。 Map 接口提","tags":["Java","源码","集合框架"],"title":"Map接口源码分析","type":"post","url":"/post/java/map-source-analysis/","weight":0,"wordcount":2592},{"author":null,"categories":["JAVA"],"content":null,"date":1566385200,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":600,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1566385200,"objectID":"0acf1575f63f4585dc29c54b76bbc2ce","permalink":"https://cuilan.github.io/post/java/abstractqueue-source-analysis/","publishdate":"2019-08-21T11:00:00Z","readingtime":2,"relpermalink":"/post/java/abstractqueue-source-analysis/","section":"post","summary":"java.util.AbstractQueue 类继承自 java.util.AbstractCollection 抽象类，实现了 java.util.Queue 接口。 AbstractQueue继承关系 一、AbstractQueue特点或规范 AbstractQueue 类提供 队列Queue 操作的基础","tags":["Java","源码","集合框架"],"title":"AbstractQueue源码分析","type":"post","url":"/post/java/abstractqueue-source-analysis/","weight":0,"wordcount":565},{"author":null,"categories":["JAVA"],"content":null,"date":1566313200,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":2100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1566313200,"objectID":"51e7421c5e02d87bcefa1fff8b60b630","permalink":"https://cuilan.github.io/post/java/treeset-source-analysis/","publishdate":"2019-08-20T15:00:00Z","readingtime":5,"relpermalink":"/post/java/treeset-source-analysis/","section":"post","summary":"java.util.TreeSet 类继承自 java.util.AbstractSet 抽象类，实现了 java.util.NavigableSet、java.lang.Cloneable、java.io.Serial","tags":["Java","源码","集合框架"],"title":"TreeSet源码分析","type":"post","url":"/post/java/treeset-source-analysis/","weight":0,"wordcount":2048},{"author":null,"categories":["JAVA"],"content":null,"date":1566230400,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":500,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1566230400,"objectID":"e4385c50cb38700789a2d9225d68fa80","permalink":"https://cuilan.github.io/post/java/linkedhashset-source-analysis/","publishdate":"2019-08-19T16:00:00Z","readingtime":1,"relpermalink":"/post/java/linkedhashset-source-analysis/","section":"post","summary":"java.util.LinkedHashSet 类继承自 java.util.HashSet 抽象类，实现了 java.util.Set、java.lang.Cloneable、java.io.Serializable 接口。","tags":["Java","源码","集合框架"],"title":"LinkedHashSet源码分析","type":"post","url":"/post/java/linkedhashset-source-analysis/","weight":0,"wordcount":497},{"author":null,"categories":["JAVA"],"content":null,"date":1566208800,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1300,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1566208800,"objectID":"9c2a5f95825da892b07acb4f6b9561ac","permalink":"https://cuilan.github.io/post/java/hashset-source-analysis/","publishdate":"2019-08-19T10:00:00Z","readingtime":3,"relpermalink":"/post/java/hashset-source-analysis/","section":"post","summary":"java.util.HashSet 类继承自 java.util.AbstractSet 抽象类，实现了 java.util.Set、java.lang.Cloneable、java.io.Serializable 接口。","tags":["Java","源码","集合框架"],"title":"HashSet源码分析","type":"post","url":"/post/java/hashset-source-analysis/","weight":0,"wordcount":1236},{"author":null,"categories":["JAVA"],"content":null,"date":1565956800,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":500,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1565956800,"objectID":"dc576926c25f2aca69c509c6b702e07e","permalink":"https://cuilan.github.io/post/java/abstractset-source-analysis/","publishdate":"2019-08-16T12:00:00Z","readingtime":1,"relpermalink":"/post/java/abstractset-source-analysis/","section":"post","summary":"java.util.AbstractSet 抽象类继承自 java.util.AbstractCollection 抽象类，实现了 java.util.Set 接口。 AbstractSet继承关系 一、AbstractSet特点或规范 AbstractSet 类提供了 Set 接口的基础实现，以最大限","tags":["Java","源码","集合框架"],"title":"AbstractSet源码分析","type":"post","url":"/post/java/abstractset-source-analysis/","weight":0,"wordcount":490},{"author":null,"categories":["JAVA"],"content":null,"date":1565352000,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1300,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1565352000,"objectID":"b1643bc7def1565d4f79d3023a55b94e","permalink":"https://cuilan.github.io/post/java/abstractsequentiallist-source-analysis/","publishdate":"2019-08-09T12:00:00Z","readingtime":3,"relpermalink":"/post/java/abstractsequentiallist-source-analysis/","section":"post","summary":"java.util.AbstractSequentialList 抽象类继承自 java.util.AbstractList 抽象类。 AbstractSequentialList继承关系 一、AbstractSequentialList特点或规范 此类以","tags":["Java","源码","集合框架"],"title":"AbstractSequentialList源码分析","type":"post","url":"/post/java/abstractsequentiallist-source-analysis/","weight":0,"wordcount":1239},{"author":null,"categories":["JAVA"],"content":null,"date":1565092800,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1500,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1565092800,"objectID":"bb03d7e089553463c74b102b6bfcd7d8","permalink":"https://cuilan.github.io/post/java/deque-source-analysis/","publishdate":"2019-08-06T12:00:00Z","readingtime":3,"relpermalink":"/post/java/deque-source-analysis/","section":"post","summary":"java.util.Deque 接口直接继承自 java.util.Queue 接口。 Deque接口继承关系 一、Deque接口特点或规范 Deque 是线性集合，最大的特点是支持 两端插入、移除元素。Deque 是 \u0026ldquo;double ended","tags":["Java","源码","集合框架"],"title":"Deque接口源码分析","type":"post","url":"/post/java/deque-source-analysis/","weight":0,"wordcount":1453},{"author":null,"categories":["JAVA"],"content":null,"date":1565028000,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1000,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1565028000,"objectID":"7303a300384aa04316717813286ef192","permalink":"https://cuilan.github.io/post/java/queue-source-analysis/","publishdate":"2019-08-05T18:00:00Z","readingtime":2,"relpermalink":"/post/java/queue-source-analysis/","section":"post","summary":"java.util.Queue 接口直接继承自 java.util.Collection 接口。 Queue接口继承关系 一、Queue接口特点或规范 除了基本的 Collection 功能外，队列还提供额外的 插入，提取 和 检查 三组操作。其中","tags":["Java","源码","集合框架"],"title":"Queue接口源码分析","type":"post","url":"/post/java/queue-source-analysis/","weight":0,"wordcount":920},{"author":null,"categories":["JAVA"],"content":null,"date":1564682400,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1564682400,"objectID":"87feee2cec2e7321fab6c741cb5515d0","permalink":"https://cuilan.github.io/post/java/navigableset-source-analysis/","publishdate":"2019-08-01T18:00:00Z","readingtime":3,"relpermalink":"/post/java/navigableset-source-analysis/","section":"post","summary":"java.util.NavigableSet 接口直接继承自 java.util.SortedSet 接口。 NavigableSet接口继承关系 一、NavigableSet接口特点或规范 java.util.NavigableSet 接口在 java.util.SortedSet 基础上增加了导航功能，使用导","tags":["Java","源码","集合框架"],"title":"NavigableSet接口源码分析","type":"post","url":"/post/java/navigableset-source-analysis/","weight":0,"wordcount":1064},{"author":null,"categories":["JAVA"],"content":null,"date":1564527600,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1564527600,"objectID":"1164e6101a1ee6c07c0b043019ff43f6","permalink":"https://cuilan.github.io/post/java/sortedset-source-analysis/","publishdate":"2019-07-30T23:00:00Z","readingtime":3,"relpermalink":"/post/java/sortedset-source-analysis/","section":"post","summary":"java.util.SortedSet 接口直接继承自 java.util.Set 接口。 SortedSet接口继承关系 一、SortedSet接口特点或规范 实现规范 在 java.util.Set 基础上进一步提供其元素的总排序。元素按","tags":["Java","源码","集合框架"],"title":"SortedSet接口源码分析","type":"post","url":"/post/java/sortedset-source-analysis/","weight":0,"wordcount":1011},{"author":null,"categories":["JAVA"],"content":null,"date":1563962400,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":3500,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1563962400,"objectID":"358296608fa9871fe51465c80be70eb4","permalink":"https://cuilan.github.io/post/java/abstractlist-source-analysis/","publishdate":"2019-07-24T10:00:00Z","readingtime":7,"relpermalink":"/post/java/abstractlist-source-analysis/","section":"post","summary":"java.util.AbstractList 抽象类继承了 java.util.AbstractCollection 类，实现了 java.util.List 接口。 AbstractList继承关系 一、AbstractList类继承规范 随机访问性与顺序访问性规范 AbstractList 类提供了","tags":["Java","源码","集合框架"],"title":"AbstractList源码分析","type":"post","url":"/post/java/abstractlist-source-analysis/","weight":0,"wordcount":3412},{"author":null,"categories":["JAVA"],"content":null,"date":1563465300,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":300,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1563465300,"objectID":"ace241b21cdd900533728c532e78d4aa","permalink":"https://cuilan.github.io/post/java/set-source-analysis/","publishdate":"2019-07-18T15:55:00Z","readingtime":1,"relpermalink":"/post/java/set-source-analysis/","section":"post","summary":"java.util.Set 接口直接继承自 java.util.Collection 接口。 Set接口继承关系 一、Set接口特点或规范 不包含重复元素。至多一个 null 元素。数学意义的集合。 全部方法都继承自 java.util.Collection 接口。 子","tags":["Java","源码","集合框架"],"title":"Set接口源码分析","type":"post","url":"/post/java/set-source-analysis/","weight":0,"wordcount":292},{"author":null,"categories":["JAVA"],"content":null,"date":1563408000,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":2500,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1563408000,"objectID":"c6b3ee46032f8aaf32cddd93ca32e667","permalink":"https://cuilan.github.io/post/java/abstractcollection-source-analysis/","publishdate":"2019-07-18T00:00:00Z","readingtime":5,"relpermalink":"/post/java/abstractcollection-source-analysis/","section":"post","summary":"java.util.AbstractCollection 抽象类实现了 java.util.Collection 接口。 AbstractCollection继承关系 一、AbstractCollection类继承规范 AbstractCollection 抽象类提供了 Collection 接口的骨","tags":["Java","源码","集合框架"],"title":"AbstractCollection源码分析","type":"post","url":"/post/java/abstractcollection-source-analysis/","weight":0,"wordcount":2473},{"author":null,"categories":["JAVA"],"content":null,"date":1563377640,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1900,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1563377640,"objectID":"110c0e90d35862e9f453b7ef43d7554f","permalink":"https://cuilan.github.io/post/java/list-source-analysis/","publishdate":"2019-07-17T15:34:00Z","readingtime":4,"relpermalink":"/post/java/list-source-analysis/","section":"post","summary":"java.util.List 接口直接继承自 java.util.Collection 接口，在 Collection 接口的功能之上添加了 List 功能特有的接口规范。 List接口继承关系 一、List接口特点 有序集合。 该接口的子类实现可以","tags":["Java","源码","集合框架"],"title":"List接口源码分析","type":"post","url":"/post/java/list-source-analysis/","weight":0,"wordcount":1807},{"author":null,"categories":["JAVA"],"content":null,"date":1563188520,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1900,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1563188520,"objectID":"1c53ad3f89081cab5021444bda2df9ed","permalink":"https://cuilan.github.io/post/java/collection-source-analysis/","publishdate":"2019-07-15T11:02:00Z","readingtime":4,"relpermalink":"/post/java/collection-source-analysis/","section":"post","summary":"java.util.Collection 接口是单列集合层次结构中的 根接口。集合表示 一组对象，称为其 元素。其有些子类集合允许重复元素，有些其他集合则不允许。有些是有序的，有些是无序","tags":["Java","源码","集合框架"],"title":"Collection接口源码分析","type":"post","url":"/post/java/collection-source-analysis/","weight":0,"wordcount":1859},{"author":null,"categories":["JAVA"],"content":null,"date":1562926702,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":600,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1562926702,"objectID":"612dba622ae390dfa4790de99fdcbab3","permalink":"https://cuilan.github.io/post/java/iterable-source-analysis/","publishdate":"2019-07-12T10:18:22Z","readingtime":2,"relpermalink":"/post/java/iterable-source-analysis/","section":"post","summary":"实现此接口的对象成为“for-each loop”语句的目标，即具有可迭代功能。 Iterable 接口在 java.lang 包下，java.util.Collection 接口实","tags":["Java","源码","集合框架"],"title":"Iterable接口源码分析","type":"post","url":"/post/java/iterable-source-analysis/","weight":0,"wordcount":584},{"author":null,"categories":["JAVA"],"content":null,"date":1562920260,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1562920260,"objectID":"12d2f896ef62aa56dbf84310bde66639","permalink":"https://cuilan.github.io/post/java/javacollectionsframework/","publishdate":"2019-07-12T16:31:00+08:00","readingtime":1,"relpermalink":"/post/java/javacollectionsframework/","section":"post","summary":"一、接口 单列集合接口 java.lang.Iterable java.util.Collection java.util.List java.util.Set java.util.SortedSet java.util.NavigableSet java.util.Queue java.util.Deque 双列集合接口 java.util.Map java.util.SortedMap java.util.NavigableMap 二、抽象类/类，继承关系，实现接口 单列集合类 java.util.AbstractCollection java.util.AbstractList java.util.ArrayList java.util.AbstractSequentialList java.util.LinkedList java.util.Vector java.util.Stack java.util.AbstractSet java.util.HashSet java.util.LinkedHashSet java.util.TreeSet java.util.AbstractQueue java.util.ArrayDeque 双列集合类 java.util.AbstractMap java.util.HashMap java.util.LinkedHashMap","tags":["Java","源码","集合框架","目录"],"title":"Java集合框架源码分析","type":"post","url":"/post/java/javacollectionsframework/","weight":0,"wordcount":80},{"author":null,"categories":["并发编程"],"content":null,"date":1562701141,"description":"","dir":"post/并发编程/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":800,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1562701141,"objectID":"4b206b1f12423a9d7358f5e77a2b7672","permalink":"https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E4%B8%AD%E7%9A%84%E9%94%81%E4%B8%80/","publishdate":"2019-07-09T19:39:01Z","readingtime":2,"relpermalink":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E4%B8%AD%E7%9A%84%E9%94%81%E4%B8%80/","section":"post","summary":"锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，如：","tags":["Java","并发","多线程"],"title":"Java中的锁（Lock接口）","type":"post","url":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E4%B8%AD%E7%9A%84%E9%94%81%E4%B8%80/","weight":0,"wordcount":754},{"author":null,"categories":["并发编程"],"content":null,"date":1559259300,"description":"","dir":"post/并发编程/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1559259300,"objectID":"2cb9b655b62bc740a2806ca21031ce28","permalink":"https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9B%9B/","publishdate":"2019-05-30T23:35:00Z","readingtime":3,"relpermalink":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9B%9B/","section":"post","summary":"1、volatile的特性 可见性：对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。 原子性：对任意单个 volatile 变量的读/写具有原子性","tags":["Java","并发","多线程"],"title":"Java内存模型四（volatile内存语义）","type":"post","url":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9B%9B/","weight":0,"wordcount":1074},{"author":null,"categories":["并发编程"],"content":null,"date":1559173020,"description":"","dir":"post/并发编程/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":900,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1559173020,"objectID":"80b2025b848e17b6fc9c9e1564d2c582","permalink":"https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%89/","publishdate":"2019-05-29T23:37:00Z","readingtime":2,"relpermalink":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%89/","section":"post","summary":"顺序一致性内存模型 是一个理论参考模型。处理器的内存模型 和 编程语言的内存模型 都会以其作为参考。 1、数据竞争与顺序一致性 Java内存模型规范对 数","tags":["Java","并发","多线程"],"title":"Java内存模型三（顺序一致性）","type":"post","url":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%89/","weight":0,"wordcount":860},{"author":null,"categories":["并发编程"],"content":null,"date":1559000026,"description":"","dir":"post/并发编程/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":800,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1559000026,"objectID":"9724d461f03dfaa3d8aa4dd4d08bf3da","permalink":"https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BA%8C/","publishdate":"2019-05-27T23:33:46Z","readingtime":2,"relpermalink":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BA%8C/","section":"post","summary":"重排序：指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。 1、数据依赖性 如果两个操作访问同一个变量，且这两个操作中有一个为","tags":["Java","并发","多线程"],"title":"Java内存模型二（重排序）","type":"post","url":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BA%8C/","weight":0,"wordcount":795},{"author":null,"categories":["并发编程"],"content":null,"date":1558563961,"description":"","dir":"post/并发编程/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1700,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1558563961,"objectID":"171a6f4a46734705fdac90b491726ca6","permalink":"https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%80/","publishdate":"2019-05-22T22:26:01Z","readingtime":4,"relpermalink":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%80/","section":"post","summary":"Java内存模型的基础：主要介绍内存模型相关的基本概念 Java内存模型中的顺序一致性：主要介绍 重排序 与 顺序一致性内存模型 同步原语：主要介绍3","tags":["Java","并发","多线程"],"title":"Java内存模型一（基础）","type":"post","url":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%80/","weight":0,"wordcount":1608},{"author":null,"categories":["并发编程"],"content":null,"date":1554157751,"description":"","dir":"post/并发编程/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1554157751,"objectID":"be6f72e42a8a850c8eb7a6a375bad82b","permalink":"https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%89/","publishdate":"2019-04-01T22:29:11Z","readingtime":3,"relpermalink":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%89/","section":"post","summary":"原子操作：不可被中断的一个或一系列操作。 一、处理器如何实现原子操作 使用总线锁保证原子性 第一个机制是通过总线锁保证原子性。如果多个处理器同时对","tags":["Java","并发","多线程"],"title":"Java并发机制的底层实现原理（原子操作）","type":"post","url":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%89/","weight":0,"wordcount":1015},{"author":null,"categories":["并发编程"],"content":null,"date":1553127363,"description":"","dir":"post/并发编程/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1600,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1553127363,"objectID":"4eb18d0498c0fe3fa5f1db073d1ca3e3","permalink":"https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BA%8C/","publishdate":"2019-03-21T00:16:03Z","readingtime":4,"relpermalink":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BA%8C/","section":"post","summary":"synchronized 一般称之为重量级锁，在Java1.6中对 synchronized 进行了各种优化，在有些情况下它并不那么重了。 利用synchronized实现同步的基础 在Java","tags":["Java","并发","多线程"],"title":"Java并发机制的底层实现原理（synchronized）","type":"post","url":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BA%8C/","weight":0,"wordcount":1573},{"author":null,"categories":["JAVA"],"content":null,"date":1552649031,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1400,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1552649031,"objectID":"667a48a37d2905b1806295acf08c4de9","permalink":"https://cuilan.github.io/post/java/java-object-head/","publishdate":"2019-03-15T11:23:51Z","readingtime":3,"relpermalink":"/post/java/java-object-head/","section":"post","summary":"由于Java面向对象的思想，在JVM中需要大量存储对象，存储时为了实现一些额外的功能，需要在对象中添加一些标记字段用于增强对象功能，这些标记","tags":["Java"],"title":"Java对象头详解","type":"post","url":"/post/java/java-object-head/","weight":0,"wordcount":1351},{"author":null,"categories":["并发编程"],"content":null,"date":1551828027,"description":"","dir":"post/并发编程/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1551828027,"objectID":"531ba2841779bf8b4a53f0c0ffc1c966","permalink":"https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%80/","publishdate":"2019-03-05T23:20:27Z","readingtime":3,"relpermalink":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%80/","section":"post","summary":"Java中所使用的并发机制依赖于JVM的实现和CPU的指令。在多线程并发编程中 synchronized 和 volatile 都扮演着重要的角色。 volatile的应用 volatile 是轻量级的 s","tags":["Java","并发","多线程"],"title":"Java并发机制的底层实现原理（volatile）","type":"post","url":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%80/","weight":0,"wordcount":1012},{"author":null,"categories":["并发编程"],"content":null,"date":1551741068,"description":"","dir":"post/并发编程/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":2500,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1551741068,"objectID":"4855716c4be0dcf3c2a443af4291b86f","permalink":"https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","publishdate":"2019-03-04T23:11:08Z","readingtime":5,"relpermalink":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","section":"post","summary":"Java并发编程的缺陷 上下文切换带来的CPU开销 死锁 物理硬件的限制 软件资源的限制 为什么需要并发？ 并发其实是一种解耦合的策略，这种策略帮助我们","tags":["Java","并发","多线程"],"title":"Java并发解决方案","type":"post","url":"/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","weight":0,"wordcount":2437},{"author":null,"categories":["杂项"],"content":null,"date":1546994099,"description":"","dir":"post/杂项/概率论与数理统计/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":700,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1546994099,"objectID":"471a60ff1cea1d0c47ec990d37ff86df","permalink":"https://cuilan.github.io/post/%E6%9D%82%E9%A1%B9/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E4%BA%8C%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E9%97%B4%E7%9A%84%E8%BF%90%E7%AE%97%E5%BE%8B/","publishdate":"2019-01-09T00:34:59Z","readingtime":2,"relpermalink":"/post/%E6%9D%82%E9%A1%B9/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E4%BA%8C%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E9%97%B4%E7%9A%84%E8%BF%90%E7%AE%97%E5%BE%8B/","section":"post","summary":"\u003ch2 id=\"基本定律\"\u003e基本定律：\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e幂等律\u003c/strong\u003e：A∪A = A，A∩A = A\n\u003cstrong\u003e交换律\u003c/strong\u003e：A∪B = B∪A，A∩B = B∩A\n\u003cstrong\u003e结合律\u003c/strong\u003e：(A∪B)∪C = A∪(B∪C)，(A∩B)∩C = A∩(B∩C)\n\u003cstrong\u003e分配律\u003c/strong\u003e：A∩(B∪C) = (A∩B)∪(A∩C)，A∪(B∩C) = (A∪B)∩(A∪C)\u003c/p\u003e\n\u003ch2 id=\"demorgan德摩根定律\"\u003eDe·Morgan（德·摩根）定律：\u003c/h2\u003e\n\u003cp\u003e非(A且B) = 非A或非B\n\n  \u003cfigure\u003e\n    \u003cimg src=\"/images/%e6%9d%82%e9%a1%b9/%e4%ba%8c%e3%80%81%e9%9a%8f%e6%9c%ba%e4%ba%8b%e4%bb%b6%e9%97%b4%e7%9a%84%e8%bf%90%e7%ae%97%e5%be%8b/1.png\" alt=\"德·摩根\"\u003e\n    \u003ccenter\u003e\u003cfigcaption\u003e德·摩根\u003c/figcaption\u003e\u003c/center\u003e\n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cp\u003e非(A或B) = 非A且非B\n\n  \u003cfigure\u003e\n    \u003cimg src=\"/images/%e6%9d%82%e9%a1%b9/%e4%ba%8c%e3%80%81%e9%9a%8f%e6%9c%ba%e4%ba%8b%e4%bb%b6%e9%97%b4%e7%9a%84%e8%bf%90%e7%ae%97%e5%be%8b/2.png\" alt=\"德·摩根\"\u003e\n    \u003ccenter\u003e\u003cfigcaption\u003e德·摩根\u003c/figcaption\u003e\u003c/center\u003e\n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\n  \u003cfigure\u003e\n    \u003cimg src=\"/images/%e6%9d%82%e9%a1%b9/%e4%ba%8c%e3%80%81%e9%9a%8f%e6%9c%ba%e4%ba%8b%e4%bb%b6%e9%97%b4%e7%9a%84%e8%bf%90%e7%ae%97%e5%be%8b/3.png\" alt=\"德·摩根\"\u003e\n    \u003ccenter\u003e\u003cfigcaption\u003e德·摩根\u003c/figcaption\u003e\u003c/center\u003e\n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\n  \u003cfigure\u003e\n    \u003cimg src=\"/images/%e6%9d%82%e9%a1%b9/%e4%ba%8c%e3%80%81%e9%9a%8f%e6%9c%ba%e4%ba%8b%e4%bb%b6%e9%97%b4%e7%9a%84%e8%bf%90%e7%ae%97%e5%be%8b/4.png\" alt=\"德·摩根\"\u003e\n    \u003ccenter\u003e\u003cfigcaption\u003e德·摩根\u003c/figcaption\u003e\u003c/center\u003e\n  \u003c/figure\u003e\n\n\u003c/p\u003e","tags":["概率论","统计学"],"title":"二、随机事件间的运算律","type":"post","url":"/post/%E6%9D%82%E9%A1%B9/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E4%BA%8C%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E9%97%B4%E7%9A%84%E8%BF%90%E7%AE%97%E5%BE%8B/","weight":0,"wordcount":684},{"author":null,"categories":null,"content":null,"date":1546994099,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1546994099,"objectID":"","permalink":"https://cuilan.github.io/categories/%E6%9D%82%E9%A1%B9/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/categories/%E6%9D%82%E9%A1%B9/","section":"categories","summary":"","tags":null,"title":"杂项","type":"categories","url":"/categories/%E6%9D%82%E9%A1%B9/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1546994099,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1546994099,"objectID":"","permalink":"https://cuilan.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/","section":"tags","summary":"","tags":null,"title":"概率论","type":"tags","url":"/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1546994099,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1546994099,"objectID":"","permalink":"https://cuilan.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/","section":"tags","summary":"","tags":null,"title":"统计学","type":"tags","url":"/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/","weight":0,"wordcount":0},{"author":null,"categories":["杂项"],"content":null,"date":1546904214,"description":"","dir":"post/杂项/概率论与数理统计/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1000,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1546904214,"objectID":"7ba0790c888a92945d4551db3a5f5b16","permalink":"https://cuilan.github.io/post/%E6%9D%82%E9%A1%B9/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E4%B8%80%E6%A6%82%E7%8E%87%E4%B8%8E%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6/","publishdate":"2019-01-07T23:36:54Z","readingtime":2,"relpermalink":"/post/%E6%9D%82%E9%A1%B9/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E4%B8%80%E6%A6%82%E7%8E%87%E4%B8%8E%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6/","section":"post","summary":"\u003ch2 id=\"随机试验experiment\"\u003e随机试验（Experiment）\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e定义：对事物的某一特征的观察。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e其典型的例子有：\u003c/em\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eE\u003c!-- raw HTML omitted --\u003e1\u003c!-- raw HTML omitted --\u003e\u003c/strong\u003e：抛一枚硬币，观察正面H（Heads）、反面T（Tails）出现的情况。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eE\u003c!-- raw HTML omitted --\u003e2\u003c!-- raw HTML omitted --\u003e\u003c/strong\u003e：抛一颗骰子，观察出现的点数。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eE\u003c!-- raw HTML omitted --\u003e3\u003c!-- raw HTML omitted --\u003e\u003c/strong\u003e：观察某一时间段通过某一路口的车辆数。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eE\u003c!-- raw HTML omitted --\u003e4\u003c!-- raw HTML omitted --\u003e\u003c/strong\u003e：观察某一电子元件的寿命。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eE\u003c!-- raw HTML omitted --\u003e5\u003c!-- raw HTML omitted --\u003e\u003c/strong\u003e：观察某地区一昼夜的最低温度和最高温度。\u003c/li\u003e\n\u003c/ul\u003e","tags":["概率论","统计学"],"title":"一、概率与随机事件","type":"post","url":"/post/%E6%9D%82%E9%A1%B9/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E4%B8%80%E6%A6%82%E7%8E%87%E4%B8%8E%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6/","weight":0,"wordcount":926},{"author":null,"categories":null,"content":null,"date":1545221963,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1545221963,"objectID":"","permalink":"https://cuilan.github.io/tags/nginx/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/nginx/","section":"tags","summary":"","tags":null,"title":"nginx","type":"tags","url":"/tags/nginx/","weight":0,"wordcount":0},{"author":null,"categories":["中间件"],"content":null,"date":1545221963,"description":"","dir":"post/中间件/nginx/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1200,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1545221963,"objectID":"ca6d8f671fa6876ce806f6732a96e16b","permalink":"https://cuilan.github.io/post/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/nginx-high/","publishdate":"2018-12-19T12:19:23Z","readingtime":3,"relpermalink":"/post/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/nginx-high/","section":"post","summary":"一、Nginx的反向代理 反向代理服务器： Nginx反向代理 优势： 隔离内部服务器，提高安全性。 可以在代理服务器上增加缓存，减少后端服务器的压力","tags":["中间件","nginx"],"title":"Nginx高级","type":"post","url":"/post/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/nginx-high/","weight":0,"wordcount":1198},{"author":null,"categories":null,"content":null,"date":1545221963,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1545221963,"objectID":"","permalink":"https://cuilan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/","section":"categories","summary":"","tags":null,"title":"中间件","type":"categories","url":"/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1545221963,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1545221963,"objectID":"","permalink":"https://cuilan.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/","section":"tags","summary":"","tags":null,"title":"中间件","type":"tags","url":"/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/","weight":0,"wordcount":0},{"author":null,"categories":["中间件"],"content":null,"date":1544715084,"description":"","dir":"post/中间件/nginx/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1800,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1544715084,"objectID":"22eca4c9117c2bf5ce032c39c79fd4e5","permalink":"https://cuilan.github.io/post/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/nginx-base/","publishdate":"2018-12-13T15:31:24Z","readingtime":4,"relpermalink":"/post/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/nginx-base/","section":"post","summary":"一、什么是 Nginx？ Nginx 是一款性能极高的 HTTP 反向代理服务器，Nginx 官方发布的测试数据显示，支持10000非活动的连接只需2.5M内存的性能","tags":["中间件","nginx"],"title":"Nginx基础","type":"post","url":"/post/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/nginx-base/","weight":0,"wordcount":1758},{"author":null,"categories":["JAVA"],"content":null,"date":1544137805,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":3100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1544137805,"objectID":"6b7cd9d2dc639bda7f811d5a1c0548bb","permalink":"https://cuilan.github.io/post/java/linked-list-source-analysis/","publishdate":"2018-12-06T23:10:05Z","readingtime":7,"relpermalink":"/post/java/linked-list-source-analysis/","section":"post","summary":"一、LinkedList简介二、成员分析三、链表实现四、双端队列实现五、队列实现六、栈实现七、列表实现八、迭代器、分割器一、LinkedLi","tags":["Java","源码","集合框架"],"title":"LinkedList源码分析","type":"post","url":"/post/java/linked-list-source-analysis/","weight":0,"wordcount":3088},{"author":null,"categories":["JAVA"],"content":null,"date":1542320813,"description":"","dir":"post/java/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":3300,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1542320813,"objectID":"acca1414cf3e28202baf0f8d0e89bfb8","permalink":"https://cuilan.github.io/post/java/array-list-source-analysis/","publishdate":"2018-11-15T22:26:53Z","readingtime":7,"relpermalink":"/post/java/array-list-source-analysis/","section":"post","summary":"ArrayList应该算是日常开发中使用最多的List实现类。 一、ArrayList 的特性 有序 可重复 线程不安全 允许插入 null 值 查询快、增删慢 底层","tags":["Java","源码","集合框架"],"title":"ArrayList源码分析","type":"post","url":"/post/java/array-list-source-analysis/","weight":0,"wordcount":3201},{"author":null,"categories":null,"content":null,"date":1541690018,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1541690018,"objectID":"","permalink":"https://cuilan.github.io/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/","section":"categories","summary":"","tags":null,"title":"Java虚拟机","type":"categories","url":"/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/","weight":0,"wordcount":0},{"author":null,"categories":["Java虚拟机"],"content":null,"date":1541690018,"description":"","dir":"post/jvm/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1541690018,"objectID":"65e25f5fbd8f8e1b530aabca94946425","permalink":"https://cuilan.github.io/post/jvm/jvm-gc-log/","publishdate":"2018-11-08T15:13:38Z","readingtime":3,"relpermalink":"/post/jvm/jvm-gc-log/","section":"post","summary":"每一种收集器的日志形式都是由它们自身的实现所决定的，换而言之，每个收集器的日志格式都可以不一样。但虚拟机设计者为了方便用户阅读，将各个收集器","tags":["Java","虚拟机"],"title":"七、理解GC日志","type":"post","url":"/post/jvm/jvm-gc-log/","weight":0,"wordcount":1059},{"author":null,"categories":null,"content":null,"date":1541690018,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1541690018,"objectID":"","permalink":"https://cuilan.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/","section":"tags","summary":"","tags":null,"title":"虚拟机","type":"tags","url":"/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/","weight":0,"wordcount":0},{"author":null,"categories":["Java虚拟机"],"content":null,"date":1541689977,"description":"","dir":"post/jvm/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":9800,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1541689977,"objectID":"e5fb784424f45667367272a7db31c865","permalink":"https://cuilan.github.io/post/jvm/jvm-garbage-collector/","publishdate":"2018-11-08T15:12:57Z","readingtime":20,"relpermalink":"/post/jvm/jvm-garbage-collector/","section":"post","summary":"收集算法是内存回收的方法论，而 垃圾收集器就是内存回收的具体实现 。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、","tags":["Java","虚拟机"],"title":"六、垃圾收集器","type":"post","url":"/post/jvm/jvm-garbage-collector/","weight":0,"wordcount":9710},{"author":null,"categories":["Java虚拟机"],"content":null,"date":1541687085,"description":"","dir":"post/jvm/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":2000,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1541687085,"objectID":"ba98bc07ea64274535edf93ceab443c7","permalink":"https://cuilan.github.io/post/jvm/jvm-hotspot-algorithm/","publishdate":"2018-11-08T14:24:45Z","readingtime":4,"relpermalink":"/post/jvm/jvm-hotspot-algorithm/","section":"post","summary":"枚举根节点 以可达性分析中从GC Roots节点找引用链这个操作为例， 可作为GC Roots的节点主要在全局性的引用（如常量或类静态属性）与执行上","tags":["Java","虚拟机"],"title":"五、HotSpot的算法实现","type":"post","url":"/post/jvm/jvm-hotspot-algorithm/","weight":0,"wordcount":1945},{"author":null,"categories":["Java虚拟机"],"content":null,"date":1541679266,"description":"","dir":"post/jvm/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1600,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1541679266,"objectID":"b52b9510b85be401548a0c8c4186a851","permalink":"https://cuilan.github.io/post/jvm/jvm-gc-algorithm/","publishdate":"2018-11-08T12:14:26Z","readingtime":4,"relpermalink":"/post/jvm/jvm-gc-algorithm/","section":"post","summary":"标记-清除算法 最基础的收集算法是“ 标记-清除 ”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段： 首先标记出","tags":["Java","虚拟机"],"title":"四、垃圾回收算法","type":"post","url":"/post/jvm/jvm-gc-algorithm/","weight":0,"wordcount":1538},{"author":null,"categories":["Java虚拟机"],"content":null,"date":1541611792,"description":"","dir":"post/jvm/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":3500,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1541611792,"objectID":"b6a751024ce2ed605b8dcced9c4a4740","permalink":"https://cuilan.github.io/post/jvm/jvm-gc-memory-strategy/","publishdate":"2018-11-07T17:29:52Z","readingtime":7,"relpermalink":"/post/jvm/jvm-gc-memory-strategy/","section":"post","summary":"1、概述 第一门正真使用内存动态分配和垃圾回收技术的语言是Lisp语言。 在Java各内存区域中，程序计数器、虚拟机栈、本地方法区3个区域随线程","tags":["Java","虚拟机"],"title":"三、垃圾收集器与内存分配策略","type":"post","url":"/post/jvm/jvm-gc-memory-strategy/","weight":0,"wordcount":3418},{"author":null,"categories":["Java虚拟机"],"content":null,"date":1541608523,"description":"","dir":"post/jvm/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1900,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1541608523,"objectID":"6dcfed85a211d238857f3ab626d21fc4","permalink":"https://cuilan.github.io/post/jvm/jvm-object-model/","publishdate":"2018-11-07T16:35:23Z","readingtime":4,"relpermalink":"/post/jvm/jvm-object-model/","section":"post","summary":"虚拟机内部细节，各虚拟机厂商的实现略有差异，因此以主流的Oracle HotSpot虚拟机为例分析。 1、对象的创建 Java是一门面向对象的编程","tags":["Java","虚拟机"],"title":"二、HotSpot虚拟机对象模型","type":"post","url":"/post/jvm/jvm-object-model/","weight":0,"wordcount":1853},{"author":null,"categories":["Java虚拟机"],"content":null,"date":1541605049,"description":"","dir":"post/jvm/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":2500,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1541605049,"objectID":"e27028437ed8252ad18749e6d977ee90","permalink":"https://cuilan.github.io/post/jvm/jvm-memory-exceptions/","publishdate":"2018-11-07T15:37:29Z","readingtime":5,"relpermalink":"/post/jvm/jvm-memory-exceptions/","section":"post","summary":"1、概述 Java虚拟机自动内存管理机制，不需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄露和内存溢出的问题，由","tags":["Java","虚拟机"],"title":"一、Java内存区域与内存溢出异常","type":"post","url":"/post/jvm/jvm-memory-exceptions/","weight":0,"wordcount":2408}]