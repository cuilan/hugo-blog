<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java虚拟机 on 翠兰 - Greenland</title>
    <link>https://cuilan.github.io/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/</link>
    <description>Recent content in Java虚拟机 on 翠兰 - Greenland</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 08 Nov 2018 15:13:38 +0000</lastBuildDate>
    
	<atom:link href="https://cuilan.github.io/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>七、理解GC日志</title>
      <link>https://cuilan.github.io/posts/jvm/jvm-gc-log/</link>
      <pubDate>Thu, 08 Nov 2018 15:13:38 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/jvm/jvm-gc-log/</guid>
      <description>每一种收集器的日志形式都是由它们自身的实现所决定的，换而言之，每个收集器的日志格式都可以不一样。但虚拟机设计者为了方便用户阅读，将各个收集器的日志都维持一定的共性，例如以下两段典型的GC日志：
33.125: [GC [DefNew: 3324K-&amp;gt;152K(3712K), 0.0025925 secs] 3324K-&amp;gt;152K(11904K), 0.0031680 secs] 100.667: [Full GC [Tenured: 0K-&amp;gt;210K(10240K), 0.0149142 secs] 4603K-&amp;gt;210K(19456K), [Perm : 2999K-&amp;gt;2999K(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs] 最前面的数字“33.125：”和“100.667：”代表了 GC发生的时间 ，这个数字的含义是 从Java虚拟机启动以来经过的秒数 。
GC日志开头的“ ［GC ”和“ ［Full GC ”说明了这次垃圾收集的停顿类型， 而不是用来区分新生代GC还是老年代GC的 。如果有“Full”，说明这次GC是发生了Stop-The-World的，例如下面这段新生代收集器ParNew的日志也会出现“［Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。 如果是调用System.gc()方法所触发的收集，那么在这里将显示“［Full GC (System)” 。
[Full GC 283.736: [ParNew: 261599K-&amp;gt;261599K(261952K), 0.0000288 secs] 接下来的“［ DefNew ”、“ ［Tenured ”、“ ［Perm ”表示 GC发生的区域 ， 这里显示的区域名称与使用的GC收集器是密切相关的 ，例如上面样例所使用的Serial收集器中的新生代名为“Default New Generation”，所以显示的是“［DefNew”。如果是ParNew收集器，新生代名称就会变为“［ParNew”，意为“Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。
后面方括号内部的“ 3324K-&amp;gt;152K(3712K) ”含义是“ GC前该内存区域已使用容量-&amp;gt; GC后该内存区域已使用容量 (该内存区域总容量) ”。而在方括号之外的“ 3324K-&amp;gt;152K(11904K) ”表示“ GC前Java堆已使用容量 -&amp;gt; GC后Java堆已使用容量 (Java堆总容量) ”。</description>
    </item>
    
    <item>
      <title>六、垃圾收集器</title>
      <link>https://cuilan.github.io/posts/jvm/jvm-garbage-collector/</link>
      <pubDate>Thu, 08 Nov 2018 15:12:57 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/jvm/jvm-garbage-collector/</guid>
      <description>收集算法是内存回收的方法论，而 垃圾收集器就是内存回收的具体实现 。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。这里讨论的收集器基于JDK 1.7 Update 14之后的HotSpot虚拟机（在这个版本中正式提供了商用的G1收集器，之前G1仍处于实验状态），这个虚拟机包含的所有收集器如所示。
上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器 。
Serial收集器 Serial收集器是最基本、发展历史最悠久的收集器 ，曾经（在JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。看名字就会知道， 这个收集器是一个单线程的收集器 ，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。“Stop The World”这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。下图示意了Serial / Serial Old收集器的运行过程。
对于“Stop The World”带给用户的不良体验，虚拟机的设计者们表示完全理解，但也表示非常委屈：“你妈妈在给你打扫房间的时候，肯定也会让你老老实实地在椅子上或者房间外待着，如果她一边打扫，你一边乱扔纸屑，这房间还能打扫完？”这确实是一个合情合理的矛盾，虽然垃圾收集这项工作听起来和打扫房间属于一个性质的，但实际上肯定还要比打扫房间复杂得多！
从JDK 1.3开始，一直到现在最新的JDK 1.7，HotSpot虚拟机开发团队为消除或者减少工作线程因内存回收而导致停顿的努力一直在进行着，从Serial收集器到Parallel收集器，再到Concurrent Mark Sweep（CMS）乃至GC收集器的最前沿成果Garbage First（G1）收集器，我们看到了一个个越来越优秀（也越来越复杂）的收集器的出现，用户线程的停顿时间在不断缩短，但是仍然没有办法完全消除（这里暂不包括RTSJ中的收集器）。寻找更优秀的垃圾收集器的工作仍在继续！
写到这里，笔者似乎已经把Serial收集器描述成一个“老而无用、食之无味弃之可惜”的鸡肋了，但实际上到现在为止，它依然是虚拟机运行在Client模式下的默认新生代收集器。它也有着优于其他收集器的地方： 简单而高效 （与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。
ParNew收集器 ParNew收集器其实就是Serial收集器的多线程版本 ，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、 -XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。ParNew收集器的工作过程如图所示。
ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处，但 它却是许多运行在Server模式下的虚拟机中首选的新生代收集器 ，其中有一个与性能无关但很重要的原因是，除了Serial收集器外， 目前只有它能与CMS收集器配合工作 。在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器——CMS收集器（Concurrent Mark Sweep，本节稍后将详细介绍这款收集器），这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作，用前面那个例子的话来说，就是做到了在你的妈妈打扫房间的时候你还能一边往地上扔纸屑。
不幸的是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。ParNew收集器也是使用-XX:+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX:+UseParNewGC选项来强制指定它。
ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时系统资源的有效利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多（譬如32个，现在CPU动辄就4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。
注意　从ParNew收集器开始，后面还会接触到几款并发和并行的收集器。在大家可能产生疑惑之前，有必要先解释两个名词：并发和并行。这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们可以解释如下。
  并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
  并发（Concurrent） ：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。
  Parallel Scavenge收集器 Parallel Scavenge收集器是一个新生代收集器 ，它也是使用复制算法的收集器，又是并行的多线程收集器……看上去和ParNew都一样，那它有什么特别之处呢？
Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即 吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间 ），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</description>
    </item>
    
    <item>
      <title>五、HotSpot的算法实现</title>
      <link>https://cuilan.github.io/posts/jvm/jvm-hotspot-algorithm/</link>
      <pubDate>Thu, 08 Nov 2018 14:24:45 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/jvm/jvm-hotspot-algorithm/</guid>
      <description>枚举根节点 以可达性分析中从GC Roots节点找引用链这个操作为例， 可作为GC Roots的节点主要在全局性的引用（如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中 ，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。 另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行——这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有Java执行线程（Sun将这件事情称为“Stop The World”）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。
目前的主流Java虚拟机使用的都是准确式GC，当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用 。在HotSpot的实现中，是使用一组称为OopMap（Ordinary Object Pointer）的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。
安全点 在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。
实际上，HotSpot也的确没有为每条指令都生成OopMap ，前面已经提到， 只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停 。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。
对于Sefepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来 。这里有两种方案可供选择： 抢先式中断 （Preemptive Suspension）和 主动式中断 （Voluntary Suspension），其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。 现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件 。
而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。
安全区域 使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却并不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候 线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决 。
安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。
在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止 。</description>
    </item>
    
    <item>
      <title>四、垃圾回收算法</title>
      <link>https://cuilan.github.io/posts/jvm/jvm-gc-algorithm/</link>
      <pubDate>Thu, 08 Nov 2018 12:14:26 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/jvm/jvm-gc-algorithm/</guid>
      <description>标记-清除算法 最基础的收集算法是“ 标记-清除 ”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段： 首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 ，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。标记—清除算法的执行过程如图所示。
复制算法 为了解决效率问题，一种称为“ 复制 ”（Copying）的收集算法出现了，它 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉 。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。复制算法的执行过程如图所示。
现在的商业虚拟机都采用这种收集算法来回收新生代 ，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1∶1的比例来划分内存空间， 而是将内存分为一块较大的Eden空间和两块较小的Survivor空间 ，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。 HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费” 。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行 分配担保 （Handle Promotion）。 如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代 。
标记-整理算法 复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况， 所以在老年代一般不能直接选用复制算法 。 根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如图所示。
分代收集算法 当前商业虚拟机的垃圾收集都采用“ 分代收集 ”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收 。</description>
    </item>
    
    <item>
      <title>三、垃圾收集器与内存分配策略</title>
      <link>https://cuilan.github.io/posts/jvm/jvm-gc-memory-strategy/</link>
      <pubDate>Wed, 07 Nov 2018 17:29:52 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/jvm/jvm-gc-memory-strategy/</guid>
      <description>1、概述 第一门正真使用内存动态分配和垃圾回收技术的语言是Lisp语言。
在Java各内存区域中，程序计数器、虚拟机栈、本地方法区3个区域随线程而生，随线程而灭，这几个区域的内存分配和垃圾回收都具有确定性 ，这几个区域内就不需要过多的考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。我们只需要考虑Java堆和方法区中的内存即可。
2、对象回收算法 引用计数算法 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，引用器值就减1；任何时刻计数器为0点对象就是不可能再被使用的。
但至少主流的Java虚拟机里没有选用引用计数算法来管理内存 ，其中最主要的原因是它很难解决对象之间相互循环引用的问题。
可达性分析算法 在主流的商用程序语言 （Java、C#，甚至包括前面提到的古老的Lisp）的主流实现中， 都是称通过可达性分析（Reachability Analysis）来判定对象是否存活的 。这个算法的基本思路就是通过一系列的称为“ GC Roots ”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为 引用链 （Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。如图所示，对象object 5、object 6、object 7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。
在Java语言中，可作为GC Roots的对象包括下面几种：  虚拟机栈（栈帧中的本地变量表）中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI（即一般说的Native方法）引用的对象。  对象的四种引用 无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“ 引用 ”有关。在JDK 1.2以前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。
在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱 。
强引用就是指在程序代码之中普遍存在的， 类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象 。
软引用是用来描述一些 还有用但并非必需的对象 。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。
弱引用也是用来描述 非必需对象 的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。
虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例 。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。
对象回收时的自我拯救 即使在可达性分析算法中不可达的对象，也并非是“非死不可”的 ，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程： 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行” 。</description>
    </item>
    
    <item>
      <title>二、HotSpot虚拟机对象模型</title>
      <link>https://cuilan.github.io/posts/jvm/jvm-object-model/</link>
      <pubDate>Wed, 07 Nov 2018 16:35:23 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/jvm/jvm-object-model/</guid>
      <description>虚拟机内部细节，各虚拟机厂商的实现略有差异，因此以主流的Oracle HotSpot虚拟机为例分析。
1、对象的创建 Java是一门面向对象的编程语言，在语言层面上，创建对象（例如克隆，反序列化）通常仅仅是一个new关键字而已，而在虚拟机中，对象（进限于普通Java对象，不包括数组和Class对象等）的创建过程为：
加载相应的类 ：当虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用的类是否已被加载、解析和初始化过。如果没有，则必须先执行响应的类的加载过程。
分配内存 ：对象所需内存的大小在类加载完成后便可完全确定。此过程等同于为把一块确定大小的内存从Java堆中划分出来。划分方法主要有 指针碰撞 和 空闲列表 两种分配方式，而选择哪种方式由Java堆内存是否规整决定，Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
a、指针碰撞 如果java堆中内存是绝对规整的，所有用过的内存都放在一边，未使用的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针指向空闲空间那边挪动一段与对象大小相等的距离。
b、空闲列表 如果java堆中的内存并不是规整的，已使用的内存和未使用的内存相互交错，就无法使用指针碰撞了，虚拟机必须维护一个列表来记录哪些内存是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新表上的记录。
后续工作 ：内存分配完成后，虚拟机需要将分配到的内存空间初始化为零值(不包括对象头)，然后再对对象进行必要的设置（主要是对象头信息的设置）。此时，在虚拟机看来一个新的对象已经产生了，但是从程序员的角度来看，对象创建才刚刚开始，需要执行方法，把对象按照程序员的意愿进行初始化。
2、对象的内存划分 在HotSpot虚拟机中，对象在内存中存储的布局分为3块区域： 对象头 （Header）、 实例数据 （Instance Data）和 对齐填充 （Padding）。
对象头信息： 包括两部分信息（平均分配），第一部分用于存储对象自身的运行时数据，如哈希吗、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称为“Mark Work”。对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。
实例数据： 是对象真正的存储的有效信息，也是在程序中所定义的各种类型的字段内容。无论是从父类中继承下来的，还是在子类中定义的，都需要记录下来。 存储顺序会受到分配策略参数和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oop（Ordinary Object Pointers），相同宽度的字段总是被分配到一起。在满足这个前提条件下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。
对齐填充： 并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用。而HotSpot VM的自动内存管理系统要求对象的大小必须是8字节的整数倍。对象头部分正好是8字节的倍数（1倍或者2倍），因此当对象实例数据部分没有对齐时，就需要对齐填充来补充。
3、对象的访问定位 Java程序需要通过栈上的引用数据来操作堆上的具体对象 。对象的访问方式取决于虚拟机实现，目前主流的访问方式有使用句柄和直接指针两种。
句柄： 可以理解为指向指针的指针（句柄池，也在堆中），维护指向对象的指针变化，而对象的句柄本身不发生变化。
优势 ：引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。
指针： 指向对象，代表对象的内存地址。如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 引用中存储的直接就是对象地址 。
优势 ：速度更快，节省了一次指针定位的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。
HotSpot虚拟机使用第二种方式进行对象访问。</description>
    </item>
    
    <item>
      <title>一、Java内存区域与内存溢出异常</title>
      <link>https://cuilan.github.io/posts/jvm/jvm-memory-exceptions/</link>
      <pubDate>Wed, 07 Nov 2018 15:37:29 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/jvm/jvm-memory-exceptions/</guid>
      <description>1、概述 Java虚拟机自动内存管理机制，不需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄露和内存溢出的问题，由虚拟机管理着一切。
2、运行时数据区域 程序计数器（线程私有） 程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器，字节码解释器在工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
Java虚拟机栈（线程私有） 生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型；每个方法在执行的时候会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中入栈（压栈）到出栈（弹栈）的过程。 局部变量表 存放了编译期可知的各种 基本数据类型 （byte、short、int、long、boolean、float、double、char）、 对象引用 （ reference类型 （不同于对象本身，可能是一个指向对象其实地址的引用指针，也可能是一个代表对象的句柄或其他与此对象相关的位置）、 returnAddress类型 （指向了一条字节码执行的地址））。其中64位长度的long、double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占1个。 局部变量表所需的内存空间在编译期间完成分配，进入一个方法时，需要在栈帧中分配多大的内存是完全确定的，在方法运行期间不会改变局部变量表的大小 。 在Java虚拟机规范中，对此区域规定了两种异常状况： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常 ；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可以动态扩展，只不过Java虚拟机Java虚拟机规范中也允许固定长度的虚拟机栈）， 如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常 。
本地方法栈 本地方法栈与虚拟机栈的作用非常相似，区别：虚拟机栈是为执行Java方法（字节码）服务， 本地方法栈则为虚拟机使用到的Native方法服务 。 本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常 。注意：在HotSpot虚拟机中本地方法栈和虚拟机栈合二为一。
Java堆（Java Heap） Java堆是Java虚拟机所管理的内存中最大的一块。堆内存被所有的线程共享，在虚拟机启动时创建，此区域唯一的目的就是为了存放对象实例，几乎所有的对象实例都在这里分配内存。在Java虚拟机规范中的描述是： 所有的对象实例及数组都要在堆上分配 。 Java堆是垃圾收集器管理的主要区域（因此也叫：GC堆）。由于现在收集器基本都采用分带收集算法，所以Java堆中还可以细分为： 新生代和年老代 ，再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。 从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。 根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现上，堆内存既可以是固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出outOfMemoryError异常 。
方法区（Method Area） 与堆一样，是各个线程共享的内存区域， 用于存储已被虚拟机加载的类信息、异常、静态变量、即时编译器编译后的代码等数据 。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但它的别名叫 Non-Heap（非堆） ，目的是与Java堆分开。 在HotSpot虚拟机中，方法区也被叫做“永久代”，但本质上两者并不等价， 在JDK8之后HotSpot取消了永久代，引入了元空间的内存管理机制。在JDK7中，已经把原本放在永久代的字符串常量池移出 。 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常 。
运行时常量池 运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的 版本信息、字段、方法、接口等描述信息 外，还有一项信息是常量池， 用于存放编译器生成的各种字面量和字符号引用 ，这部分内容将在类加载后进入方法区的运行时常量池中存放。 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，即并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，如：String类的intern()方法。 同方法区一样，当无法申请到新的内存时，会抛出OutOfMemoryError异常 。</description>
    </item>
    
  </channel>
</rss>