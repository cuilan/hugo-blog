<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 翠兰 - Greenland</title>
    <link>https://cuilan.github.io/tags/java/</link>
    <description>Recent content in Java on 翠兰 - Greenland</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 14 Nov 2019 15:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://cuilan.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>3.SpringMVC的请求如何分发？</title>
      <link>https://cuilan.github.io/posts/spring/springmvc/springmvc-03/</link>
      <pubDate>Thu, 14 Nov 2019 15:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/spring/springmvc/springmvc-03/</guid>
      <description></description>
    </item>
    
    <item>
      <title>2.SpringMVC核心分发器DispatcherServlet分析</title>
      <link>https://cuilan.github.io/posts/spring/springmvc/springmvc-02/</link>
      <pubDate>Mon, 04 Nov 2019 15:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/spring/springmvc/springmvc-02/</guid>
      <description>一、SpringMVC入口 SpringMVC启动类为：org.springframework.web.servlet.DispatcherServlet
由此可以看出 DispatcherServlet 本质上是继承自 javax.servlet.Servlet 顶级接口，因此其生命周期为：init() --&amp;gt; service() --&amp;gt; destory()。
继承关系如下：
 javax.servlet.Servlet  javax.servlet.GenericServlet  javax.servlet.http.HttpServlet  org.springframework.web.servlet.HttpServletBean  org.springframework.web.servlet.FrameworkServlet  org.springframework.web.servletDispatcherServlet            所以，SpringMVC启动时，是由 servlet容器（tomcat）调用执行 init() 方法，而 HttpServletBean 中覆盖了 init()方法，并 final 修饰，DispatcherServlet 和 FrameworkServlet 中都无法再继续覆盖，因此启动时会调用 HttpServletBean.init() 方法。
 二、init()方法，对初始化过程进行处理 init() 方法执行过程大概分为三步：
1.设置web.xml中的配置参数 ServletConfigPropertyValues 是 HttpServletBean 的内部静态类，构造过程中会使用 ServletConfig 对象找出 web.xml 配置文件中的配置参数并设置到 ServletConfigPropertyValues 中。
2.初始化BeanWrapper 使用 BeanWrapper 来构造实例化 DispatcherServlet 对象（即：this当前对象），接着通过当前 this 对象的 getServletContext() 方法获取 servlet 上下文信息，并创建 ServletContextResourceLoader 对象，给 bw 注册 Resource 类型的属性编辑器，然后调用 initBeanWrapper() 进行初始化（空方法，供子类进行扩展），初始化后，给 bw 对象设置属性值，即 web.</description>
    </item>
    
    <item>
      <title>1.SpringMVC使用示例</title>
      <link>https://cuilan.github.io/posts/spring/springmvc/springmvc-01/</link>
      <pubDate>Wed, 30 Oct 2019 12:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/spring/springmvc/springmvc-01/</guid>
      <description>SpringMVC项目的演示示例，包含 maven 依赖配置，web.xml 文件配置，spring-mvc.xml 文件配置等，代码部分省略。
创建maven工程 &amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd&amp;#34;&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;artifactId&amp;gt;spring-all&amp;lt;/artifactId&amp;gt; &amp;lt;groupId&amp;gt;cn.cuilan&amp;lt;/groupId&amp;gt; &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;artifactId&amp;gt;spring-mvc&amp;lt;/artifactId&amp;gt; &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt; &amp;lt;name&amp;gt;spring-mvc&amp;lt;/name&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-context-support&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.freemarker&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;freemarker&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${freemarker.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;build&amp;gt; &amp;lt;finalName&amp;gt;spring-mvc&amp;lt;/finalName&amp;gt; &amp;lt;resources&amp;gt; &amp;lt;resource&amp;gt; &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt; &amp;lt;/resource&amp;gt; &amp;lt;resource&amp;gt; &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt; &amp;lt;/resource&amp;gt; &amp;lt;resource&amp;gt; &amp;lt;directory&amp;gt;src/main/webapp&amp;lt;/directory&amp;gt; &amp;lt;/resource&amp;gt; &amp;lt;/resources&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;artifactId&amp;gt;maven-war-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt; &amp;lt;/project&amp;gt; 创建 spring-mvc.xml 配置文件 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:context=&amp;#34;http://www.springframework.org/schema/context&amp;#34; xsi:schemaLocation=&amp;#34; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.</description>
    </item>
    
    <item>
      <title>SpringMVC目录</title>
      <link>https://cuilan.github.io/posts/spring/springmvc/springmvc/</link>
      <pubDate>Tue, 29 Oct 2019 12:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/spring/springmvc/springmvc/</guid>
      <description>1.SpringMVC使用示例2.SpringMVC核心分发器DispatcherServlet分析</description>
    </item>
    
    <item>
      <title>Java中的锁-AbstractQueuedSynchronizer队列同步器</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E4%B8%AD%E7%9A%84%E9%94%81%E4%BA%8C/</link>
      <pubDate>Thu, 19 Sep 2019 12:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E4%B8%AD%E7%9A%84%E9%94%81%E4%BA%8C/</guid>
      <description>AbstractQueuedSynchronizer 同步器提供了一个框架，用于构建 先进先出(FIFO) 等待队列的 阻塞锁 和 相关同步器（信号量，事件等）。它使用了一个 int 成员变量表示同步状态，通过 FIFO 队列来完成资源获取线程的排队工作。
一、同步器的使用  同步器的主要使用方式是 继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。 使用同步器提供的3个方法：getState()，setState(int newState) 和 compareAndSetState(int expect, int update) 进行操作，因为以上方法可以保证状态的改变是安全的。 子类应定义为非公共的静态内部类。  访问或修改同步状态的3个方法 源码中这三个方法都被定义为 final，子类不可以重写。
 getState()：获取当前同步状态。 setState(int newState)：设置当前同步状态。 compareAndSetState(int expect, int update)：使用 CAS 设置当前状态，该方法能保证状态设置的原子性。   二、独占模式和共享模式 AbstractQueuedSynchronizer 支持 独占模式（默认） 和 共享模式 两种。
 独占模式下，当一个线程获取到锁，其他线程只能处于同步队列中等待，只有获取到锁的线程释放了锁，其他线程才能获取锁。 共享模式下，多个线程可以同时获取锁，并发的访问资源，如：ReadWriteLock。  通常，子类实现仅支持其中的一种模式，但在 ReadWriteLock 读写锁中两种模式都可以发挥作用。
2.1 同步器可重写的方法 仅支持独占模式的子类无需重写：tryAcquireShared()、tryReleaseShared() 方法。 仅支持共享模式的子类无需重写：tryAcquire()、tryRelease() 方法。
   方法名称 功能描述     boolean tryAcquire(int arg) 独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态十分符合预期，然后进行CAS设置同步状态。   boolean tryRelease(int arg) 独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态。   int tryAcquireShared(int arg) 共享式获取同步状态，返回大于等于0的值，表示获取成功，反之，获取失败。   boolean tryReleaseShared(int arg) 共享式释放同步状态。   boolean isHeldExclusively() 当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所占有。    2.</description>
    </item>
    
    <item>
      <title>Java并发编程目录</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Tue, 17 Sep 2019 23:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9B%AE%E5%BD%95/</guid>
      <description>Java并发机制的底层实现原理（volatile）Java并发机制的底层实现原理（synchronized）Java并发机制的底层实现原理（原子操作）Java内存模型一（基础）Java内存模型二（重排序）Java内存模型三（顺序一致性）Java内存模型四（volatile内存语义）Java中的锁（Lock接口）</description>
    </item>
    
    <item>
      <title>Dictionary抽象类源码分析</title>
      <link>https://cuilan.github.io/posts/javase/dictionary-source-analysis/</link>
      <pubDate>Tue, 17 Sep 2019 16:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/dictionary-source-analysis/</guid>
      <description>一、Dictionary特点或规范 Dictionary 抽象类形式上等同于一个接口，其全部方法都是抽象方法。它是 Hashtable 的父类，它将 键 映射到 值。每个键和每个值都是一个对象。在任何一个 Dictionary 对象中，每个键最多与一个值相关联。给定一个 Dictionary 和一个键，可以查找关联的元素。任何非 null 对象都可以用作键和值。通常，此类的实现应使用 equals() 方法来确定两个键是否相同。
注意：此类已过时。
 二、构造器 唯一空参构造器。
public Dictionary() { }  三、方法描述 abstract public int size(); abstract public boolean isEmpty(); abstract public Enumeration&amp;lt;K&amp;gt; keys(); abstract public Enumeration&amp;lt;V&amp;gt; elements(); abstract public V get(Object key); abstract public V put(K key, V value); abstract public V remove(Object key); </description>
    </item>
    
    <item>
      <title>TreeMap源码分析</title>
      <link>https://cuilan.github.io/posts/javase/treemap-source-analysis/</link>
      <pubDate>Tue, 17 Sep 2019 12:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/treemap-source-analysis/</guid>
      <description>java.util.TreeMap 类继承了 java.util.AbstractMap 抽象类，实现了 java.util.NavigableMap、java.lang.Cloneable、java.io.Serializable 接口。
 一、TreeMap特点或规范 TreeMap 是基于 红黑树 的 NavigableMap 实现。根据其 key 的 自然顺序 进行排序，或者根据使用的构造器在 Map 创建时提供的比较器进行排序。
由于底层采用了红黑树的数据结构，因此 TreeMap 的查询方法，如：containsKey()，get()，put()，remove()，其时间复杂度均为：O(logn)。
注意：TreeMap 不同步。 如果多个线程同时访问，并且至少有一个线程进行了结构上的修改，则必须在外部进行同步；如下：
SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));
注意：此类中的方法返回的所有 Map.Entry 都它们不支持 Entry.setValue() 方法；可以使用 put(K, V) 方法更改 Entry 中的值。
 二、成员变量 2.1 常量 // 虚拟值 private static final Object UNBOUNDED = new Object(); // 表示红色节点 private static final boolean RED = false; // 表示黑色节点 private static final boolean BLACK = true; // 指定 Map 中的比较器 private final Comparator&amp;lt;?</description>
    </item>
    
    <item>
      <title>LinkedHashMap源码分析</title>
      <link>https://cuilan.github.io/posts/javase/linkedhashmap-source-analysis/</link>
      <pubDate>Sun, 15 Sep 2019 01:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/linkedhashmap-source-analysis/</guid>
      <description>java.util.LinkedHashMap 类继承了 java.util.HashMap 类，实现了 java.util.Map 接口。
 一、LinkedHashMap特点或规范 1.1 特点 java.util.LinkedHashMap 是 java.util.Map 接口的 链表 + 哈希 实现，具有可预测的迭代顺序；与 HashMap 的不同是在 HashMap 的基础上使用了双向链表的数据结构；并按照插入顺序排序。
linkedHashMap 与 HashMap 比较：
   特性 LinkedHashMap HashMap     有序性 有序 无序   数据结构 数组 - 链表 - 红黑树 数组 - 链表 - 红黑树 + 双向链表   空键 允许 允许   空值 允许 允许    1.2 LRU缓存 LinkedHashMap 提供了一个特殊的构造函数来构建 LRU 缓存（Least Recent Used最近最少使用），构造器如下：</description>
    </item>
    
    <item>
      <title>HashMap.TreeNode类源码分析</title>
      <link>https://cuilan.github.io/posts/javase/hashmap-treenode/</link>
      <pubDate>Wed, 11 Sep 2019 17:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/hashmap-treenode/</guid>
      <description>继承关系：
 java.util.Map.Entry Map 接口中的顶层实体接口。  java.util.HashMap.Node HashMap 中的单向链表节点。  java.util.LinkedHashMap.Entry LinkedHashMap 中的双向链表节点。  java.util.HashMap.TreeNode HashMap 中的红黑树节点。         一、HashMap节点内部类 HashMap 中节点内部类有两种实现：
 链表节点：HashMap.Node 红黑树节点：HashMap.TreeNode  有关 HashMap 数据结构、方法分析、哈希冲突 及 链表实现等，见：HashMap源码分析。
 二、链表-红黑树 相互转换的方法 treeifyBin(Node, int) 方法 转换为红黑树结构：根据 hash 值计算待转换的链表在 哈希表(table) 的位置，如果否满足转换为红黑树的条件，就进行转换。
执行过程分析：
 哈希表（数组）是否已初始化：  未初始化，调用 resize() 进行初始化。 或已初始化，判断哈希表的长度是否小于 64：  小于 64，不考虑使用红黑树结构，调用 resize() 重新计算大小。 大于等于 64，转换为红黑树结构。      final void treeifyBin(Node&amp;lt;K,V&amp;gt;[] tab, int hash) { int n, index; Node&amp;lt;K,V&amp;gt; e; // 如果哈希表 tab 没有初始化，或长度小于最小 64，则 resize()  if (tab == null || (n = tab.</description>
    </item>
    
    <item>
      <title>HashMap源码分析</title>
      <link>https://cuilan.github.io/posts/javase/hashmap-source-analysis/</link>
      <pubDate>Tue, 03 Sep 2019 17:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/hashmap-source-analysis/</guid>
      <description>java.util.HashMap 类继承了 java.util.AbstractMap 抽象类，实现了 java.util.Map、java.lang.Cloneable、java.io.Serializable 接口。
一、HashMap特点或规范二、成员属性三、构造器四、内部类：Node，即：Map.Entry五、继承自AbstractMap的方法六、实现自Map接口的方法七、静态工具方法八、其他主要方法九、迭代器十、红黑树 一、HashMap特点或规范 HashMap 是基于 哈希表 的 Map 接口实现。无序 且不保证顺序永远保持不变。
1.1 与Hashtable的区别    HashMap Hashtable     不同步 同步   允许空键 不允许空键   允许空值 不允许空值    1.2 性能  通常情况下，hash(Object) 方法计算得出的哈希值都均匀的分布在 哈希桶 之间，这样可以保证 get(K) 和 put(K, V) 基本操作方法的性能为恒定时间。 对集合视图：keySet()，values()，entrySet() 的 迭代时间，与 HashMap实例的容量（桶的数量）加上其大小（K-V Node 的数量）成比例的时间。因此，如果迭代性能有较高要求，则不要将 初始容量设置得太高 或 负载因子设置得太低。 影响 HashMap 性能的两个因素：初始容量 和 负载因子。  1.3 容量capacity &amp;amp; 加载因子loadFactor  容量：哈希表中的桶数，初始容量只是创建 HashMap 时的容量。 加载因子：是一个比例值，即：已被分布的哈希桶数 / 容量；也可以描述为：扩容操作之前允许哈希桶中已被分布的桶的数量。  当 HashMap 中已被分布的桶数超过了 加载因子 * 当前容量 时，HashMap将被扩容至原来容量的两倍，并重新计算哈希值（即，重建内部数据结构）。</description>
    </item>
    
    <item>
      <title>AbstractMap源码分析</title>
      <link>https://cuilan.github.io/posts/javase/abstractmap-source-analysis/</link>
      <pubDate>Mon, 02 Sep 2019 17:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/abstractmap-source-analysis/</guid>
      <description>java.util.AbstractMap 抽象类实现了 java.util.Map 接口。
一、AbstractMap特点或规范 AbstractMap 抽象类提供了 Map 接口的基础实现，以最大限度地减少实现此接口所需的工作量。
1.1 实现不可修改的Map 要实现不可修改的 Map，子类只需要继承此类并实现 entrySet() 方法，该方法返回 Map.Entry 的 set视图。该set视图应该继承 java.util.AbstractSet，并实现抽象其方法。此set视图不应该支持 add()，remove() 方法，并且其迭代器不应支持 remove()方法。
1.2 实现可修改的Map 要实现可修改的 Map，子类必须另外覆盖此类的 put(K, V) 方法，否则会抛出 UnsupportedOperationException 异常，以及 entrySet().iterator() 返回的迭代器必须另外实现其 remove() 方法。
1.3 构造器规范 子类应该根据 Map接口的构造器规范 提供两个构造器：
 无参构造器 参数为 Map 类型的构造器   二、成员变量 仅在第一次请求 keySet() 方法时初始化实例。
transient Set&amp;lt;K&amp;gt; keySet; public Set&amp;lt;K&amp;gt; keySet() { Set&amp;lt;K&amp;gt; ks = keySet; // 只读  if (ks == null) { ks = new AbstractSet()&amp;lt;K&amp;gt; {.</description>
    </item>
    
    <item>
      <title>NavigableMap接口源码分析</title>
      <link>https://cuilan.github.io/posts/javase/navigablemap-source-analysis/</link>
      <pubDate>Wed, 28 Aug 2019 17:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/navigablemap-source-analysis/</guid>
      <description>java.util.NavigableMap 接口直接继承自 java.util.SortedMap 接口。
一、NavigableMap特点或规范 NavigableMap 使用可导航的方法扩展了 SortedMap，返回给定搜索目标的最接近匹配结果。
NavigableMap 定义了以下方法来根据 key 查询，如果不存在该 key，则返回 null：
   操作 小于 小于等于 大于等于 大于     查询满足条件的 Map.Entry lowerEntry(K) floorEntry(K) ceilingEntry(K) higherEntry(K)   查询满足条件的 key lowerKey(K) floorKey(K) ceilingKey(K) higherKey(K)    有序性  可以按 升序 或 降序 key 访问或遍历 NavigableMap。 descendingMap() 方法返回 Map 的反序视图。 navigableKeySet() 方法返回 key 的 升序 视图 descendingKeySet() 方法返回 key 的 降序 视图 升序操作及视图的性能 可能比 降序操作及视图的性能 更快。  子Map视图 子 Map 视图继承自 SortedMap，两种实现不同之处在于 是否可接受包含下限和上限参数。NavigableMap 返回的子视图也都必须实现 NavigableMap 接口。</description>
    </item>
    
    <item>
      <title>SortedMap接口源码分析</title>
      <link>https://cuilan.github.io/posts/javase/sortedmap-source-analysis/</link>
      <pubDate>Tue, 27 Aug 2019 23:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/sortedmap-source-analysis/</guid>
      <description>java.util.SortedMap 接口直接继承自 java.util.Map 接口。
一、SortedMap特点或规范  SortedMap 在 Map 的基础上进一步提供其 key 的总排序。 SortedMap 默认是根据其 key 的 自然顺序 排序的，或者根据 SortedMap 在创建时提供的比较器进行排序。 SortedMap 的集合视图：entrySet()，keySet()、values() ，在迭代这些视图时会按照顺序返回。 SortedMap 在 Map 的基础上提供了几个额外的方法扩展排序相关功能。  1.1 可比较性规范 插入到 SortedMap 中的所有 key 必须实现 Comparable 接口。此外，子类实现所有的 key 必须是 可相互比较的，即：k1.compareTo(k2) 或 comparator.compare(k1, k2)，违反此规范将导致函数调用抛出 ClassCastException。
注意：如果 SortedMap 要正确实现 Map 接口，则由 SortedMap 维护的排序（无论是否提供显式比较器）必须与 equals() 方法一致。这是因为 Map 接口是根据 equals() 方法定义的，但是有序映射使用 compareTo（或compare）方法执行所有 key 的比较，因此从 SortedMap 的角度来看，equals() 方法认为相等的两个键是相等的。
TreeMap 比较特别，它的排序与 equals() 不一致。
1.2 构造器规范 所有 SortedMap 实现类都应该提供 四个“标准”构造函数。由于接口无法指定构造函数，所以无法强制子类实现此规范。</description>
    </item>
    
    <item>
      <title>Map接口源码分析</title>
      <link>https://cuilan.github.io/posts/javase/map-source-analysis/</link>
      <pubDate>Wed, 21 Aug 2019 15:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/map-source-analysis/</guid>
      <description>java.util.Map 接口是双列集合的顶级接口。
一、Map特点或规范  双列集合，由 key 映射 value 的对象。 Map 不能包含重复的 key，且每个 key 只能映射一个 value。 Map 接口提供了三个集合的视图，key集合、value集合、**Entry&amp;lt;K, V&amp;gt;集合。 Map 的顺序定义为 集合视图 的迭代器返回其元素的顺序。 有序性  java.util.TreeMap 类有序 其他，如 java.util.HashMap 类无序    1.1 构造器规范 所有 Map 实现类都应该提供两个“标准”构造函数，Map 接口无法强制子类执行此规范（因为接口不能包含构造函数），但JDK中的所有 Map 实现都符合要求：
 无参构造器，用于创建一个空 Map。 参数类型为 Map 的构造器，它创建一个具有相同键值的新映射映射作为其论点。  1.2 key/value限制 某些 Map 实现类对可能包含的 key 和 value 有限制。如，某些实现禁止空 key 和空 value，有些实现类对键的类型有限制。如果插入不合格的 key 或 value 会引发异常，通常是 NullPointerException 或 ClassCastException。
 二、Map.Entry接口 Map.Entry 类映射实体，即：key-value 键值对。Map.</description>
    </item>
    
    <item>
      <title>AbstractQueue源码分析</title>
      <link>https://cuilan.github.io/posts/javase/abstractqueue-source-analysis/</link>
      <pubDate>Wed, 21 Aug 2019 11:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/abstractqueue-source-analysis/</guid>
      <description>java.util.AbstractQueue 类继承自 java.util.AbstractCollection 抽象类，实现了 java.util.Queue 接口。
一、AbstractQueue特点或规范 AbstractQueue 类提供 队列Queue 操作的基础实现。此类不允许 null 元素。
如果操作没有找到元素，则会抛出异常，而不会返回 false 或 null。
 add(E) 依赖 offer(E) remove() 依赖 poll() element() 依赖 peek()  继承此类的 队列Queue 实现必须实现的方法：
 Queue.offer(E) 方法，且不允许插入 null 元素 Queue.peek() Queue.poll() Collection.size() Collection.iterator()  如果无法满足特定要求，可继承 AbstractCollection。
 二、构造器 唯一构造器，由子类实现提供 Collection 规范中的两个构造器。
protected AbstractQueue() { }  三、方法分析 3.1 继承自 AbstractCollection 的方法 add(E) 方法 将指定的元素插入此队列，如果插入成功，则返回 true，否则抛出 IllegalStateException 异常。
public boolean add(E e) { if (offer(e)) return true; else throw new IllegalStateException(&amp;#34;Queue full&amp;#34;); } addAll(Collection) 方法 将指定集合中的所有元素添加到当前队列中。此实现迭代指定的集合，并依次将迭代器返回的每个元素添加到当前队列中。</description>
    </item>
    
    <item>
      <title>TreeSet源码分析</title>
      <link>https://cuilan.github.io/posts/javase/treeset-source-analysis/</link>
      <pubDate>Tue, 20 Aug 2019 15:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/treeset-source-analysis/</guid>
      <description>java.util.TreeSet 类继承自 java.util.AbstractSet 抽象类，实现了 java.util.NavigableSet、java.lang.Cloneable、java.io.Serializable 接口。
一、TreeSet特点或规范 TreeSet 是基于 java.util.TreeMap 的 java.util.NavigableSet 实现类。
 有序：元素按照其自然顺序排序，或在创建时指定比较器，具体实现取决于创建时调用的的构造函数。 不可重复。  1.1 时间复杂度 TreeSet 的基本操作（add(Object)、remove(Object)、contains(Object)）均保证了时间复杂度为 O(logN)。
1.2 有序性保证 注意：子类如果要正确实现 Set 接口，则由 Set 维护的排序（无论是否提供显式比较器）必须与 equals() 方法保持一致。 因为 Set 接口的唯一性是根据 equals() 方法决定的，而 TreeSet 是使用 compareTo() 方法实现元素比较。 TreeSet 实例即使排序与 equals() 方法不一致也是正确的，只是没有遵守 Set 接口规范。
1.3 线程不安全 注意：TreeSet 类线程不同步。 如果多个线程同时访问 TreeSet，并且至少有一个线程修改了该 Set，则必须在外部进行同步。 实现同步的方法最好在创建 TreeSet 时完成，以防止对集合的意外不同步访问：
SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...)); 1.4 并发迭代 如果在创建迭代器之后的任何时候修改了TreeSet，除了通过迭代器自己的 remove()方法之外，迭代器将抛出 ConcurrentModificationException。
 二、成员变量 TreeSet 底层由 TreeMap 实现。</description>
    </item>
    
    <item>
      <title>LinkedHashSet源码分析</title>
      <link>https://cuilan.github.io/posts/javase/linkedhashset-source-analysis/</link>
      <pubDate>Mon, 19 Aug 2019 16:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/linkedhashset-source-analysis/</guid>
      <description>java.util.LinkedHashSet 类继承自 java.util.HashSet 抽象类，实现了 java.util.Set、java.lang.Cloneable、java.io.Serializable 接口。
一、LinkedHashSet特点或规范 java.util.LinkedHashSet 类是 Set 接口的 哈希表 和 链表 双实现，保证迭代顺序。
此实现与 HashSet 的不同之处在于它维护了一个双向链表。
注意，如果将已存在的元素重新插入到集合中，不会影响插入顺序。
 二、构造器 空参构造器（遵循 Collection 接口规范） 调用父类构造器，使用 LinkedHashSet 实例，默认初始容量为 **16 **，默认加载因子为：0.75。
public LinkedHashSet() { super(16, .75f, true); } 参数为 Collection 类型的构造器（遵循 Collection 接口规范） 调用父类构造器，使用 LinkedHashMap 实例，初始容量为：集合的 2倍，默认加载因子为：0.75。
public LinkedHashSet(Collection&amp;lt;? extends E&amp;gt; c) { super(Math.max(2*c.size(), 11), .75f, true); addAll(c); } 指定初始容量和加载因子的构造器 构造一个空的 LinkedHashSet，调用父类构造器，使用 LinkedHashMap 实例，可指定 初始容量 和 加载因子。
public LinkedHashSet(int initialCapacity, float loadFactor) { super(initialCapacity, loadFactor, true); } 仅指定初始容量的构造器 构造一个空的 LinkedHashSet，调用父类构造器，使用 LinkedHashMap 实例，仅支持指定 初始容量，加载因子默认为：0.</description>
    </item>
    
    <item>
      <title>HashSet源码分析</title>
      <link>https://cuilan.github.io/posts/javase/hashset-source-analysis/</link>
      <pubDate>Mon, 19 Aug 2019 10:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/hashset-source-analysis/</guid>
      <description>java.util.HashSet 类继承自 java.util.AbstractSet 抽象类，实现了 java.util.Set、java.lang.Cloneable、java.io.Serializable 接口。
一、HashSet特点或规范 HashSet 类是 Set 接口的实现类，底层由 java.util.HashMap 实现。
 无序，不保证集合的迭代顺序 允许 null 元素。  1.1 性能  该类的基本操作（add(E)、remove(Object)、contains(Object)、size()）时间性能较高，时间复杂度为 O(1)，前提是 Hash 必须正确分布。 迭代此集合需要的时间与 HashSet 实例的大小（元素数量）加上后备 HashMap 实例的“容量”（桶数）之和成比例。因此，如果迭代性能很重要，则不要将初始容量设置得太高（或负载因子太低）。  1.2 线程不安全 注意，HashSet 线程不安全。如果多个线程同时访问，并且至少有一个线程修改了该 Set，则必须在外部进行同步。最好在创建完成时添加同步，以防止对 Set 的意外不同步访问：
Set s = Collections.synchronizedSet(new HashSet(...)); 注意：线程并发访问，可能引发 ConcurrentModificationException 异常。
 二、成员变量 HashSet 底层由 HashMap 实现，由此来保证不可重复性。
private transient HashMap&amp;lt;E,Object&amp;gt; map; // 关联 HashMap 中的 Object 虚拟值 private static final Object PRESENT = new Object();  三、构造器 空参构造器（遵循 Collection 接口规范） 使用 HashMap 实例，默认初始容量为 **16 **，默认加载因子为：0.</description>
    </item>
    
    <item>
      <title>AbstractSet源码分析</title>
      <link>https://cuilan.github.io/posts/javase/abstractset-source-analysis/</link>
      <pubDate>Fri, 16 Aug 2019 12:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/abstractset-source-analysis/</guid>
      <description>java.util.AbstractSet 抽象类继承自 java.util.AbstractCollection 抽象类，实现了 java.util.Set 接口。
一、AbstractSet特点或规范 AbstractSet 类提供了 Set 接口的基础实现，以最大限度地减少实现 Set 接口所需的工作量。
 子类通过此类实现集合 与 通过实现 AbstractCollection 类实现集合的过程相同，但必须遵循 Set 接口的规范。 AbstractSet 类不会覆盖 AbstractCollection 类中的任何实现。 只是添加了 equals() 和 hashCode() 的实现。  二、构造器 唯一构造器。
protected AbstractSet() { } 三、实现方法 equals(Object) 方法 将指定对象与当前 Set 进行比较。
 如果指定对象也是一个集合，且与当前 Set 引用相同则返回 true。 两个集合具有相同的大小，并且指定集合的每个成员都包含在此集合中，则返回 true。  public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Set)) return false; Collection&amp;lt;?&amp;gt; c = (Collection&amp;lt;?</description>
    </item>
    
    <item>
      <title>AbstractSequentialList源码分析</title>
      <link>https://cuilan.github.io/posts/javase/abstractsequentiallist-source-analysis/</link>
      <pubDate>Fri, 09 Aug 2019 12:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/abstractsequentiallist-source-analysis/</guid>
      <description>java.util.AbstractSequentialList 抽象类继承自 java.util.AbstractList 抽象类。
一、AbstractSequentialList特点或规范  此类以最大限度地减少实现一个 “顺序访问” 数据存储（如：链表）所需的工作量。 如需 随机访问 数据（如：数组），应优先使用 AbstractList 而不是此类。  实现此类需要实现的方法 最简实现此类，只需要提供 listIterator(int) 和 size() 方法的实现。
随机访问 此类与 AbstractList 类相反，它在 列表迭代器 上实现了 “随机访问” 的方法：get(int index)，set(int index, E element)，add(int index, E element) 和 remove(int index)。
可修改性规范  如果子类实现是不可修改的列表，只需要实现 ListIterator 的 hasNext()，next()，hasPrevious()，previous() 和 index() 方法。 如果子类实现需要可修改的列表，还应该实现 ListIterator 的 set() 方法。 如果子类实现需要可变大小的列表，还应该实现 ListIterator 的 remove() 和 add() 方法。  构造器规范 子类实现应根据 java.util.Collection 接口规范中的建议，提供：
 无参构造器 参数类型为 Collection 构造器   二、构造器 唯一构造器，protected 权限。</description>
    </item>
    
    <item>
      <title>Deque接口源码分析</title>
      <link>https://cuilan.github.io/posts/javase/deque-source-analysis/</link>
      <pubDate>Tue, 06 Aug 2019 12:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/deque-source-analysis/</guid>
      <description>java.util.Deque 接口直接继承自 java.util.Queue 接口。
一、Deque接口特点或规范  Deque 是线性集合，最大的特点是支持 两端插入、移除元素。Deque 是 &amp;ldquo;double ended queue&amp;rdquo; 的缩写。 大多数 Deque 的子类实现对其包含的元素数量没有固定限制，但此接口支持：  支持容量限制的子类实现。 支持没有容量限制子类实现。   支持访问双端队列两端的元素。 提供额外的 插入，提取 和 检查 三组操作。其中每组都以两种形式存在：  一种在操作失败时抛出异常。 一种返回特殊值（null 或 false，具体取决于操作），此形式的插入操作专门用于容量限制的队列实现；在大多数实现中，插入操作不会失败。    1.1 Deque 双端队列十二种方法摘要：     第一个元素(Head)  最后一个元素(Tail)       抛出异常 返回特殊值 抛出异常 返回特殊值   插入 addFirst(e) offerFirst(e) addLast(e) offerLast(e)   删除 removeFirst() pollFirst() removeLast() pollLast()   获取 getFirst() peekFirst() getLast() peekLast()    1.</description>
    </item>
    
    <item>
      <title>Queue接口源码分析</title>
      <link>https://cuilan.github.io/posts/javase/queue-source-analysis/</link>
      <pubDate>Mon, 05 Aug 2019 18:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/queue-source-analysis/</guid>
      <description>java.util.Queue 接口直接继承自 java.util.Collection 接口。
一、Queue接口特点或规范 除了基本的 Collection 功能外，队列还提供额外的 插入，提取 和 检查 三组操作。其中每组都以两种形式存在：
 一种在操作失败时抛出异常。 一种返回特殊值（null 或 false，具体取决于操作），此形式的插入操作专门用于容量限制的队列实现；在大多数实现中，插入操作不会失败。  1.1 队列方法摘要    操作 抛出异常 返回特殊值     插入 add(E) offer(E)   删除 remove() poll()   获取 element() peek()    1.2 队列进出顺序  队列通常（但不一定）以 FIFO（先进先出） 方式对元素进行排序。例外：  优先级队列：根据提供的比较器对元素进行排序，或者元素的自然排序。 后进先出队列（或 栈）：它们对元素 LIFO（后进先出） 进行排序。   在 FIFO 队列中，所有 新元素 都插入队列的 尾部。 无论使用什么顺序，队列的头部都是通过调用 remove() 或 poll() 方法来删除的元素。 其他类型的队列可能使用不同的放置规则。 每个 Queue 的实现都必须指定其排序属性。  1.</description>
    </item>
    
    <item>
      <title>NavigableSet接口源码分析</title>
      <link>https://cuilan.github.io/posts/javase/navigableset-source-analysis/</link>
      <pubDate>Thu, 01 Aug 2019 18:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/navigableset-source-analysis/</guid>
      <description>java.util.NavigableSet 接口直接继承自 java.util.SortedSet 接口。
一、NavigableSet接口特点或规范  java.util.NavigableSet 接口在 java.util.SortedSet 基础上增加了导航功能，使用导航方法扩展的 SortedSet 报告给定搜索目标的最接近匹配。 lower()，floor()，ceiling() 和 higher() 方法返回元素分别小于，小于或等于，大于或等于，大于给定元素，如果没有这样的元素则返回 null。 此接口还定义了 pollFirst() 和 pollLast() 方法，返回并删除最低和最高元素（如果存在），否则返回 null。 任何 NavigableSet 实现类的的子集都必须实现 NavigableSet 接口。   二、方法描述 lower(E)方法 返回当前 Set 中小于指定元素的最大元素，如果没有这样的元素，则返回 null。
E lower(E e); floor(E)方法 返回当前 Set 中小于或等于指定元素的最大元素，如果没有这样的元素，则返回 null。
E floor(E e); ceiling(E)方法 返回当前 Set 中大于或等于指定元素的最小元素，如果没有这样的元素，则返回 null。
E ceiling(E e); higher(E)方法 返回当前 Set 中大于指定元素的最小元素，如果没有这样的元素，则返回 null。
E higher(E e); pollFirst()方法 检索并删除**第一个（最低）**元素，如果没有这样的元素，则返回 null。
E pollFirst(); pollLast()方法 检索并删除**最后一个（最高）**元素，如果没有这样的元素，则返回 null。</description>
    </item>
    
    <item>
      <title>SortedSet接口源码分析</title>
      <link>https://cuilan.github.io/posts/javase/sortedset-source-analysis/</link>
      <pubDate>Tue, 30 Jul 2019 23:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/sortedset-source-analysis/</guid>
      <description>java.util.SortedSet 接口直接继承自 java.util.Set 接口。
一、SortedSet接口特点或规范 实现规范  在 java.util.Set 基础上进一步提供其元素的总排序。元素按照 自然顺序 排序，或通过创建时提供的 比较器排序。 迭代器将按 升序 顺序遍历集合。提供了几个额外的操作以利用订购。 （此接口是SortedMap的集合模拟。） 插入到 SortedSet 中的所有元素必须实现 java.lang.Comparable 接口（或指定的比较器）。 所有元素必须可相互比较，即：e1.compareTo(e2)（或 comparator.compare(e1, e2)）。 注意，如果 SortedSet 要正确实现 Set 接口，则由 SortedSet 维护的排序（无论是否提供显式比较器）必须与 equals() 方法一致。  因为 Set 接口的不可重复性依赖于 equals() 方法，而 SortedSet 使用 compareTo() 方法进行所有元素的比较，
构造器规范 所有 SortedSet 的实现类应提供 四个“标准”构造器：
 无参构造器，它根据元素的自然顺序创建一个空的 SortedSet。（Collection规范） 参数为 Collection 类型的构造器，它创建一个新的 SortedSet，其元素类型与 Collection 参数中的元素类型相同，并根据元素的自然顺序进行排序。（Collection规范） 参数为 Comparator 类型的构造器，它创建一个根据指定比较器排序的空的 SortedSet。 参数为 SortedSet 类型的构造器，它创建一个新的 SortedSet，其具有与输入的 SortedSet 相同的元素和相同的顺序。  由于接口不能包含构造函数，因此无法强制执行此规范。</description>
    </item>
    
    <item>
      <title>AbstractList源码分析</title>
      <link>https://cuilan.github.io/posts/javase/abstractlist-source-analysis/</link>
      <pubDate>Wed, 24 Jul 2019 10:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/abstractlist-source-analysis/</guid>
      <description>java.util.AbstractList 抽象类继承了 java.util.AbstractCollection 类，实现了 java.util.List 接口。
一、AbstractList类继承规范 随机访问性与顺序访问性规范  AbstractList 类提供了 List 接口的基础实现，以最大限度地减少子类且实现了 “随机访问” 数据存储（如：数组）所需的工作量（如：ArrayList）。 对于顺序访问的数据结构（如：LinkedList），应该优先使用 java.util.AbstractSequentialList，而不是此类。  可修改性规范  如果要实现不可修改的列表，子类只需要扩展此类并提供 get(int) 方法和 size() 方法的实现。 如果要实现可修改的列表，子类必须另外覆盖 set(int, E) 方法，否则会抛出 UnsupportedOperationException 异常。  大小可变性规范  如果列表是 size 是可变的，则子类必须另外覆盖 add(int, E) 方法和 remove(int) 方法，add(E) 方法已提供实现，元素默认加入列表末尾。  子类构造器规范  子类应根据 Collection 接口的规范提供 无参数构造器 和 参数为 Collection 的构造器。  迭代器规范  与其他抽象集合实现不同，子类不必提供迭代器实现；迭代器（通常是：Itr） 和 列表迭代器（通常是：ListItr） 是由这个类的 “随机访问” 方法实现的：get(int) set(int, E) add(int, E) remove(int)。  可覆盖性规范  此类中每个非抽象方法的实现。子类都可以以更高效的方式或特有的方式进行覆盖。   二、成员分析 2.</description>
    </item>
    
    <item>
      <title>AbstractCollection源码分析</title>
      <link>https://cuilan.github.io/posts/javase/abstractcollection-source-analysis/</link>
      <pubDate>Thu, 18 Jul 2019 17:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/abstractcollection-source-analysis/</guid>
      <description>java.util.AbstractCollection 抽象类实现了 java.util.Collection 接口。
一、AbstractCollection类继承规范  AbstractCollection 抽象类提供了 Collection 接口的骨干实现，以最大限度地减少实现 Collection 接口所需的工作量。 如需实现一个 不可修改的集合，只需要继承此类并提供 iterator() 方法和 size() 方法的实现。（iterator() 方法返回的迭代器必须实现 hasNext() 方法和 next()方法。） 如需实现一个 可修改的集合，则必须另外覆盖此类的 add() 方法（否则会抛出 UnsupportedOperationException 异常），iterator() 方法返回的迭代器必须另外实现其 remove() 方法。 除此之外还应该根据 Collection 接口的规范提供 无参数构造器 和 参数为 Collection 的构造器。 每个非抽象的方法都有自己的实现，如果子类需要特殊的实现，则可以覆盖对应的方法。   二、成员分析 2.1 常量 集合的最大数组大小。某些虚拟机在数组中保留一些 header words。如果尝试分配更大的数组可能会导致 OutOfMemoryError：请求的数组大小超过VM限制。
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 2.2 构造方法 唯一的构造函数。
protected AbstractCollection() { } 2.3 抽象方法 方法描述见：java.util.Collection接口。
public abstract Iterator&amp;lt;E&amp;gt; iterator(); public abstract int size(); 2.</description>
    </item>
    
    <item>
      <title>Set接口源码分析</title>
      <link>https://cuilan.github.io/posts/javase/set-source-analysis/</link>
      <pubDate>Thu, 18 Jul 2019 15:55:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/set-source-analysis/</guid>
      <description>java.util.Set 接口直接继承自 java.util.Collection 接口。
一、Set接口特点或规范   不包含重复元素。至多一个 null 元素。数学意义的集合。
  全部方法都继承自 java.util.Collection 接口。
  子类实现必须创建一个不包含重复元素的构造函数。
  子类实现必须对 equals() 和 hashCode() 方法重写，对 Set 进行 “值比较”。
  某些子类实现对其包含的元素有限制。如：
  某些实现禁止 null 元素
  某些实现对其元素的类型有限制
  二、继承自 Collection 的方法 详细方法描述，见：java.util.Collection接口。
int size(); boolean isEmpty(); boolean contains(Object o); Iterator&amp;lt;E&amp;gt; iterator(); Object[] toArray(); &amp;lt;T&amp;gt; T[] toArray(T[] a); // 修改操作 boolean add(E e); boolean remove(Object o); // 批量操作 boolean containsAll(Collection&amp;lt;?</description>
    </item>
    
    <item>
      <title>List接口源码分析</title>
      <link>https://cuilan.github.io/posts/javase/list-source-analysis/</link>
      <pubDate>Wed, 17 Jul 2019 15:34:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/list-source-analysis/</guid>
      <description>java.util.List 接口直接继承自 java.util.Collection 接口，在 Collection 接口的功能之上添加了 List 功能特有的接口规范。
一、List接口特点   有序集合。
  该接口的子类实现可以精确控制列表中每个元素的插入位置，可以通过索引访问元素，并搜索列表中的元素。
  与 Set 集合不同，通常允许重复元素，且允许 null 元素， null 元素也可重复。
  List 接口提供了一个特殊的迭代器：java.util.ListIterator，它允许元素插入和替换，以及 java.util.Iterator 接口提供的常规操作之外的双向访问。
  还提供了一种从列表的指定位置开始的迭代器：listIterator(int index)。
   二、继承自 Collection 的方法 详细方法描述，见：java.util.Collection接口。
int size(); boolean isEmpty(); boolean contains(Object o); Iterator&amp;lt;E&amp;gt; iterator(); Object[] toArray(); &amp;lt;T&amp;gt; T[] toArray(T[] a); // 修改操作 boolean add(E e); boolean remove(Object o); // 批量操作 boolean containsAll(Collection&amp;lt;?&amp;gt; c); boolean addAll(Collection&amp;lt;?</description>
    </item>
    
    <item>
      <title>Collection接口源码分析</title>
      <link>https://cuilan.github.io/posts/javase/collection-source-analysis/</link>
      <pubDate>Mon, 15 Jul 2019 11:02:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/collection-source-analysis/</guid>
      <description>java.util.Collection 接口是单列集合层次结构中的 根接口。集合表示 一组对象，称为其 元素。其有些子类集合允许重复元素，有些其他集合则不允许。有些是有序的，有些是无序的。JDK中 Collection 不提供此接口的任何直接实现：它提供了更具体的子接口（如Set和List）的实现。此接口通常用于更抽象的传递集合，并在需要最大通用性的情况下对其进行操作。
如：
Collection&amp;lt;?&amp;gt; c = new ArrayList(); Collection&amp;lt;?&amp;gt; c = new HashSet(); 一、Collection接口规范 Collection接口定义了一系列子类实现规范：
1、可重复、无序的集合（可能包含重复元素的无序集合）应直接实现此接口。
2、所 有通用Collection实现类（通常 通过其子接口间接实现Collection）应提供 两个“标准”构造函数：
 一个无参构造函数，用它来创建一个空集合。 一个为子类类型的，参数为 Collection 的构造函数，使用与其参数相同的元素来创建新集合，允许用户复制任何集合，从而生成所需实现类型的等效集合。  Collection 接口无法强制执行此规范（因为接口不能包含构造函数），但Java平台库中的所有通用 Collection 实现都符合此规范。
 二、方法描述 size()方法 返回当前集合中的元素数量。如果此集合包含元素数量大于 Integer.MAX_VALUE 个元素，则返回 Integer.MAX_VALUE。
int size(); isEmpty()方法 如果当前 Collection 不包含任何元素，则返回 true。
boolean isEmpty(); contains()方法、containsAll(Collection&amp;lt;?&amp;gt; c)方法 如果当前集合包含指定元素，则返回 true。当且仅当此集合包含至少一个元素 e 时才返回 true。(o == null ? e == null : o.equals(e))
boolean contains(Object o); 如果当前集合包含指定 Collection 中的所有元素，则返回 true。</description>
    </item>
    
    <item>
      <title>Iterable接口源码分析</title>
      <link>https://cuilan.github.io/posts/javase/iterable-source-analysis/</link>
      <pubDate>Fri, 12 Jul 2019 10:18:22 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/iterable-source-analysis/</guid>
      <description>实现此接口的对象成为“for-each loop”语句的目标，即具有可迭代功能。
Iterable 接口在 java.lang 包下，java.util.Collection 接口实现了此接口，因此 Collection 及其子类都可以使用迭代器。
一、方法描述 iterator()方法 返回 T 类型元素的迭代器。见：IteratorIterator&amp;lt;T&amp;gt; iterator(); forEach()方法 对Iterable的每个元素执行给定操作，直到处理完所有元素或操作抛出异常为止。
default void forEach(Consumer&amp;lt;? super T&amp;gt; action) { // 验证非空  Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } spliterator()方法 分割迭代器，通常由实现此接口的子类覆盖默认实现。默认实现的拆分能力较差，子类的具体实现一般性能良好，有特定的具体实现优化。
default Spliterator&amp;lt;T&amp;gt; spliterator() { return Spliterators.spliteratorUnknownSize(iterator(), 0); }  二、Iterator迭代器 集合框架的迭代器父接口。由子类提供具体实现。
java.util.Iterator 接口的定义取代了 Java Collections Framework 中的 java.util.Enumeration。 迭代器在两个方面与枚举不同：
 迭代器允许调用者在迭代期间使用定义良好的语义从底层集合中删除元素。 方法名称已得到改进。  方法描述 hasNext()方法 如果迭代具有更多元素，则返回true。
boolean hasNext(); next()方法 返回迭代中的下一个元素。
E next(); remove()方法 从当前集合中移除迭代器返回的最后一个元素（即此时 next() 返回的元素）。</description>
    </item>
    
    <item>
      <title>Java集合框架源码分析</title>
      <link>https://cuilan.github.io/posts/javase/javacollectionsframework/</link>
      <pubDate>Fri, 12 Jul 2019 16:31:00 +0800</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/javacollectionsframework/</guid>
      <description>接口 双列集合接口 java.util.Map&amp;lt;Interface&amp;gt; java.util.SortedMap&amp;lt;Interface&amp;gt; java.util.NavigableMap&amp;lt;Interface&amp;gt;
 抽象类/类，继承关系，实现接口 双列集合类 java.util.AbstractMap&amp;lt;Abstract&amp;gt; &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; java.util.Mapjava.util.HashMap&amp;lt;Class&amp;gt; &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- java.util.Mapjava.util.LinkedHashMap&amp;lt;Class&amp;gt; &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- java.util.Mapjava.util.TreeMap&amp;lt;Class&amp;gt; &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; java.util.NavigableMapjava.util.WeakHashMap&amp;lt;Class&amp;gt; &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; java.util.Mapjava.util.Dictionary&amp;lt;Abstract&amp;gt; 已过时 java.util.Hashtable&amp;lt;Class&amp;gt; 已过时 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; java.</description>
    </item>
    
    <item>
      <title>Java中的锁（Lock接口）</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E4%B8%AD%E7%9A%84%E9%94%81%E4%B8%80/</link>
      <pubDate>Tue, 09 Jul 2019 19:39:01 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E4%B8%AD%E7%9A%84%E9%94%81%E4%B8%80/</guid>
      <description>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，如：读写锁）。
在Lock接口出现之前，Java程序依靠 synchronized 关键字实现锁的功能。
Java1.5之后，并发包中新增了 Lock 接口（以及相关实现类）用来实现锁功能，它提供了与 synchronized 关键字类似的同步功能，只是使用时需要显示地获取和释放锁。
Lock接口优缺点对比： 优点：拥有锁获取与释放锁的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。
缺点：缺少了（通过synchronized块或方法锁提供的）隐式获取、释放锁的便捷性。
synchronized 关键字会隐式地获取锁，但是它将锁的获取和释放固化了，也就是先获取再释放，但同时，这种方式简化了同步的管理。
 Lock的使用 Lock lock = new ReentranLock(); lock.lock(); try { } finally { lock.unlock(); } 在finally块中释放锁，目的是保证在获取到锁之后，最终能被释放。
注意：不要将获取锁的过程卸载try块中，因为如果在获取锁（自定义实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。
 Lock接口API // 获取锁，调用该方法当前线程将会获取锁，当锁获得后，从该方法返回。 void lock(); // 可中断地获取锁，和 lock() 方法的不同之处在于该方法会响应中断，即在锁的获取中可以中断当前线程。 void lockInterruptibly() throws InterruptedException; // 尝试非阻塞的获取锁，调用该方法后立刻返回，如果能够获取则返回 true，否则返回 false。 boolean tryLock(); /** * 超时的获取锁，当前线程在以下3种情况下会返回： * 1. 当前线程在超时时间内获得了锁。 * 2. 当前线程在超时时间内被中断。 * 3. 超时时间结束，返回 false。 */ boolean tryLock(long time, TimeUnit unit) throws InterruptedException; // 释放锁。 void unlock(); // 获取等待通知组件，该组件和当前的锁绑定， // 当前线程只有获得了锁，才能调用该组件的 wait() 方法， // 而调用后，当前线程将被释放锁。 Condition newCondition(); </description>
    </item>
    
    <item>
      <title>Java内存模型四（volatile内存语义）</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9B%9B/</link>
      <pubDate>Thu, 30 May 2019 23:35:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9B%9B/</guid>
      <description>1、volatile的特性  可见性：对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。 原子性：对任意单个 volatile 变量的读/写具有原子性，但类似于 volatile++ 这种复合操作不具有原子性。  2、volatile写-读建立的happens-before关系 从 JSR-133 开始（JDK5），volatile 变量的写-读可以实现线程之间的通信。
从内存语义的角度来说，volatile 的读-写与锁的释放-获取有相同的内存效果：volatile 写和锁的释放有相同的内存语义；volatile 读和锁的获取有相同的内存语义。
volatile 变量示例：
class VolatileExample { private int a = 0; private volatile boolean flag = false; public void writer() { a = 1; // 1  flag = true; // 2  } public void reader() { if (flag) { // 3  int i = a; // 4  } } } 根据 happens-before 规则：</description>
    </item>
    
    <item>
      <title>Java内存模型三（顺序一致性）</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%89/</link>
      <pubDate>Wed, 29 May 2019 23:37:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%89/</guid>
      <description>顺序一致性内存模型 是一个理论参考模型。处理器的内存模型 和 编程语言的内存模型 都会以其作为参考。
1、数据竞争与顺序一致性 Java内存模型规范对 数据竞争 的定义：
 在一个线程中写一个变量 在另一个线程读同一个变量 而且写和读没有通过同步来排序  如果一个多线程程序能正确同步，则这个程序将是一个没有数据竞争的程序。
JMM对正确同步的多线程程序的内存一致性做了如下保证：
如果程序是正确同步的，程序的执行将具有顺序一致性，即：程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。
2、顺序一致性内存模型 &amp;amp; JMM（Java内存模型） 顺序一致性内存模型的特点：
   一个线程中的所有操作必须按照程序的顺序来执行。    不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。    注意：JMM中不保证每个操作立即对所有线程可见。
未同步程序在 JMM 中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。
JMM 的具体实现原则：在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器提供优化。
3、未同步程序的执行特性 对于未同步或未正确同步的多线程程序，JMM 只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值(0, null, false)，JMM 保证线程读操作读取到值不会凭空产生。
未同步程序在两个模型中执行的差异：
   顺序一致性模型保证单线程内的操作会按程序的顺序执行，而 JMM 不保证单线程内的操作会按程序的顺序执行。    顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而 JMM 不保证所有线程能看到一致的操作执行顺序。    JMM 不保证对64位的 long 型和 double 型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。    Java语言规范鼓励但不强求 JVM 对64位的 long 型和 double 型变量的写操作具有原子性。从 JSR-133 内存模型（JDK5）开始，仅仅只允许把一个64位 long/double型变量的写操作拆分为两个32位的写操作来执行，任何读操作在 JSR-133 中都必须具有原子性。</description>
    </item>
    
    <item>
      <title>Java内存模型二（重排序）</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BA%8C/</link>
      <pubDate>Mon, 27 May 2019 23:33:46 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BA%8C/</guid>
      <description>重排序：指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。
1、数据依赖性 如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。
数据依赖性分为下列3种：
   名 称 代码示例 说 明     写后读 a = 1; b = a; 写一个变量之后，再读这个变量   写后写 a = 1; a = 2; 写一个变量之后，在写这个变量   读后写 a = b; b = 1; 读一个变量之后，再写这个变量    以上3种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。
编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。
注意：数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。
2、as-if-serial语义 as-if-serial 语义的意思是：不管怎样重排序，单线程程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。
as-if-serial 语义使单线程程序不会发生因重排序而导致的线程安全问题，也无需担心内存可见性问题。
3、程序顺序规则 如果：
// 求圆的面积 	double pi = 3.14;	// A 	double r = 1.</description>
    </item>
    
    <item>
      <title>Java内存模型一（基础）</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%80/</link>
      <pubDate>Wed, 22 May 2019 22:26:01 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%80/</guid>
      <description>Java内存模型的基础：主要介绍内存模型相关的基本概念 Java内存模型中的顺序一致性：主要介绍 重排序 与 顺序一致性内存模型 同步原语：主要介绍3个同步原语 (synchronized、volatile、final) 的内存语义及重排序规则在处理器中的实现 Java内存模型的设计：主要介绍Java内存模型的设计原理，及其余处理器内存模型和顺序一致性内存模型的关系  1、并发编程模型的两个关键问题 在命令式编程中，线程之间的通信机制有两种：共享内存、消息传递
线程之间如何通信 通信：指线程之间以何种机制来交换信息。
 共享内存 并发模型中：线程间共享程序的公共状态，通过读 - 写内存中的公共状态进行隐式通信。 消息传递 并发模型中：线程间没有公共状态，必须通过发生消息来显式进行通信。  线程之间如何同步 同步：指程序中用于控制不同线程间操作发生的相对顺序的机制。
 **共享内存 **并发模型中：同步是显式进行的。程序员必须显式指定代码需要在线程间互斥执行。 **消息传递 **并发模型中：由于消息的发送必须在消息的接受之前，因此同步是隐式进行的。  Java的并发采用的是共享内存模型 Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。
2、Java内存模型(JMM)的抽象结构  共享变量（所有实例域、静态域、数组元素）都存储在堆内存中，堆内存在线程之间共享。 局部变量、方法定义参数、异常处理器参数，不会在线程之间共享，也不会有内存可见性问题，不受内存模型影响。  JMM决定一个线程对共享变量的写入何时对另一个线程可见。
JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中；每个线程都有一个私有的本地内存，本地内存中存储了该线程以读-写共享变量的副本。
JMM通过控制主内存与每个线程的本地内存之间的交互，来保证Java的内存可见性。
3、从源代码到指令序列的重排序 重排序分为3种：  编译器优化重排序：属于编译器重排序 指令级并行重排序：属于处理器重排序 内存系统重排序：属于处理器重排序  编译Java源代码经历的重排序顺序：Java源代码 -&amp;gt; 编译器优化重排序 -&amp;gt; 指令级并行重排序 -&amp;gt; 内存系统重排序 -&amp;gt; 最终执行的指令序列
防止重排序可能导致多线程内存可见性问题  对于编译器重排序：JMM的编译器重排序规则会禁止特定类型的编译器重排序（非所有编译器重排序都要禁止）。 对于处理器重排序：JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障，来禁止特定类型的处理器重排序。  JMM属于语言级别的内存模型，它保证不同的编译器和不同的处理器平台上，通过禁止特定类型的编译器重排序和处理器重排序，提供一致的内存可见性保证。
4、内存屏障的分类 内存屏障类型表：
   屏障类型 指令实例 说明     LoadLoad Barriers Load1;LoadLoad;Load2 确保Load1数据的装载先于Load2及所有后续装载指令的装载   StoreStore Barriers Store1;StoreStore;Store2 确保Store1数据对其他处理器可见先于Load2及所有后续存储指令的存储   LoadStore Barriers Load1;LoadStore;Store 确保Load1数据的装载先于Store2及所有后续存储指令刷新到内存   StoreLoad Barriers Store1;StoreLoad;Load2 确保Store1数据对其他处理器变得可见，先于Load2及所有后续存储指令的存储    StoreLoad Barriers 是一个“全能型”的屏障，此指令会使该屏障之前的所有内存访问指令完成之后，才执行该屏障之后的内存访问指令。因此执行该屏障的开销会很昂贵。</description>
    </item>
    
    <item>
      <title>Java并发机制的底层实现原理（原子操作）</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%89/</link>
      <pubDate>Mon, 01 Apr 2019 22:29:11 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%89/</guid>
      <description>原子操作：不可被中断的一个或一系列操作。
一、处理器如何实现原子操作 使用总线锁保证原子性 第一个机制是通过总线锁保证原子性。如果多个处理器同时对共享变量进行读改写操作（i++就是经典的读改写操作），那么共享变量就会被多个处理器同时进行操作，这样的操作就不是原子的。
要想保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。
处理器使用 总线锁 来解决这个问题。
总线锁：就是使用处理器通过的一个 LOCK # 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。
使用缓存锁保证原子性 第二个机制是通过缓存锁定来保证原子性。在同一时刻，只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这期间其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大。
缓存锁定：指内存区域如果被缓存在处理器的缓存行中，并且在 Lock 操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言 LOCK # 信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性。因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写到已被锁定的缓存行的数据时，会使缓存无效。
但是有两种情况下处理器不会使用缓存锁定：
 当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线锁定。 有些处理器不支持缓存锁定。   二、Java如何实现原子操作 在Java中可以通过 锁 和 循环CAS 的方式来实现原子操作。
使用循环CAS实现原子操作 从Java1.5开始，JDK的并发包提供了一些类来支持原子操作：
 AtomicBoolean: 用原子方式更新boolean值 AtomicInteger: 用原子方式更新int值 AtomicLong: 用原子方式更新long值 &amp;hellip;&amp;hellip;  CAS实现原子操作的三大问题  ABA问题：JDK的 Atomic包 里 AtomicStampedReference 来解决ABA问题。 循环时间长开销大 只能保证一个共享变量的原子操作：AtomicReference 来保证引用对象之间的原子性，把多个变量放在一个对象里进行CAS操作。  使用锁机制实现原子性 锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了多种锁机制，有偏向锁、轻量级锁和互斥锁。除了偏向锁，JVM实现锁的方式都用了循环CAS。即当一个线程想进入同步块的时候使用循环CAS的方式来获得锁，当它想退出同步块的时候使用循环CAS释放锁。</description>
    </item>
    
    <item>
      <title>Java并发机制的底层实现原理（synchronized）</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BA%8C/</link>
      <pubDate>Thu, 21 Mar 2019 00:16:03 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BA%8C/</guid>
      <description>synchronized 一般称之为重量级锁，在Java1.6中对 synchronized 进行了各种优化，在有些情况下它并不那么重了。
利用synchronized实现同步的基础 在Java中每一个对象都可以作为锁。具体有以下3中形式：
 对于普通同步方法，锁是当前实例对象。 对于静态同步方法，锁是当前类的 Class 对象。 对于同步方法块，锁是 synchronized 括号里配置的对象。  当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。
 Java对象头 synchronized 用的锁是存储在Java对象头里的。如果对象是数组类型，则虚拟机用3个**字宽（Word）**存储对象头，如果是非数组对象类型，则用2个字宽存储对象头。
关于Java对象头，参见：Java对象头详解
Java对象头里的 Mark Word 里默认存储对象的 HashCode、分代年龄、是否是偏向锁 和 锁标志位。32位JVM的 Mark Word的默认存储结构如下：
   锁状态 25bit 4bit 1bit是否是偏向锁 2bit锁标志位     无锁状态 对象的hashCode值 对象分代年龄 0 01   无锁状态 线程ID、Epoch 对象分代年龄 1 01     锁的升级与对比 从Java1.6开始，为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”、“轻量级锁”。共有4中状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态 和 重量级锁状态，状态随着竞争激烈逐渐升级。
1.偏向锁 偏向锁的获得
当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程进入和退出同步块时不需要进行 CAS 操作来加锁和解锁，只需简单地测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁。如果存储，则表示线程已经获得了锁。如果没有存储，则需要再测试一下 Mark Word 中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用 CAS 竞争锁；如果已设置，则尝试使用 CAS 将对象头的偏向锁指向当前线程。</description>
    </item>
    
    <item>
      <title>Java对象头详解</title>
      <link>https://cuilan.github.io/posts/javase/java-object-head/</link>
      <pubDate>Fri, 15 Mar 2019 11:23:51 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/java-object-head/</guid>
      <description>由于Java面向对象的思想，在JVM中需要大量存储对象，存储时为了实现一些额外的功能，需要在对象中添加一些标记字段用于增强对象功能，这些标记字段组成了对象头。
1.对象头形式 JVM中对象头的方式有以下两种（以32位JVM为例）：
1.1.普通对象 1.2.数组对象 2.对象头的组成 2.1.Mark Word 这部分主要用来存储对象自身的运行时数据，如hashcode、gc分代年龄等。mark word的位长度为JVM的一个Word大小，也就是说32位JVM的Mark word为32位，64位JVM为64位。 为了让一个字大小存储更多的信息，JVM将字的最低两个位设置为标记位，不同标记位下的Mark Word示意如下：
其中各部分的含义如下： lock:2位的锁状态标记位，由于希望用尽可能少的二进制位表示尽可能多的信息，所以设置了lock标记。该标记的值不同，整个mark word表示的含义不同。
   biased_lock lock 状态     0 01 无锁   1 01 偏向锁   0 00 轻量级锁   0 10 重量级锁   0 11 GC标记    biased_lock：对象是否启用偏向锁标记，只占1个二进制位。为1时表示对象启用偏向锁，为0时表示对象没有偏向锁。 age：4位的Java对象年龄。在GC中，如果对象在Survivor区复制一次，年龄增加1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，并行GC的年龄阈值为15，并发GC的年龄阈值为6。由于age只有4位，所以最大值为15，这就是 -XX:MaxTenuringThreshold 选项最大值为15的原因。 identity_hashcode：25位的对象标识Hash码，采用延迟加载技术。调用方法 System.identityHashCode()计算，并会将结果写到该对象头中。当对象被锁定时，该值会移动到管程Monitor中。 thread：持有偏向锁的线程ID。 epoch：偏向时间戳。 ptr_to_lock_record：指向栈中锁记录的指针。 ptr_to_heavyweight_monitor：指向管程Monitor的指针。
64位下的标记字与32位的相似，不再赘述：
2.2.class pointer 这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的实例。该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位。 如果应用的对象过多，使用64位的指针将浪费大量内存，统计而言，64位的JVM将会比32位的JVM多耗费50%的内存。为了节约内存可以使用选项 +UseCompressedOops 开启指针压缩，其中，oop即ordinary object pointer普通对象指针。开启该选项后，下列指针将压缩至32位：</description>
    </item>
    
    <item>
      <title>Java并发机制的底层实现原理（volatile）</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%80/</link>
      <pubDate>Tue, 05 Mar 2019 23:20:27 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%80/</guid>
      <description>Java中所使用的并发机制依赖于JVM的实现和CPU的指令。在多线程并发编程中 synchronized 和 volatile 都扮演着重要的角色。
volatile的应用 volatile 是轻量级的 synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。 如果volatile变量修饰符使用适当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。
volatile的定义与实现原理 定义： Java编程语言允许线程访问共享变量，为了确保贡献变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。 如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。
volatile的使用场景 1.防止重排序
如在并发环境下的单例模式中，可以使用 volatile 关键字来防止编译时的指令重排。
public class Singleton { public static volatile Singleton singleton; /** * 私有化构造函数，防止外部调用实例化 */ private Singleton() { } public static Singleton getInstance() { if (singleton == null) { synchronized (singleton) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } JVM实例化一个对象的过程分为三个步骤：
 分配内存空间 初始化对象 将内存空间的地址赋值给对象的引用  但由于指令的重排，在多线程的场景下，可能会先将内存空间的地址值赋值给对象的引用，然后才实例化对象。这种情况会将一个未实例化的对象引用暴露出去，因此成员变量singleton被volatile关键字修饰，并在实例化时进行双重检查加锁（Double-Checked Lock）来保证单例对象的唯一性。</description>
    </item>
    
    <item>
      <title>Java并发解决方案</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Mon, 04 Mar 2019 23:11:08 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description>Java并发编程的缺陷
 上下文切换带来的CPU开销 死锁 物理硬件的限制 软件资源的限制  为什么需要并发？ 并发其实是一种解耦合的策略，这种策略帮助我们把做什么（目标）和什么时候做（时机）分开。优点是可以明显改进应用程序的吞吐量（获得更多的CPU调度时间）和结构（程序有多个部分在协同工作）。Servlet容器就是采用单实例多线程的工作模式，来处理并发问题。
误解和正解 误解：  并发总能改进性能 编写并发程序无序修改原有的设计 在试验Web或Spring容器时不用关注并发问题  正解：  编写并发程序会在代码上增加额外的开销 正确的并发是非常复杂的没及时对于很简单的问题 并发中的缺陷因为不易重现也不容易被发现 并发往往需要对设计策略从根本上进行修改  并发编程的原则和技巧 单一职责原则 分离并发相关代码和其他代码（并发相关代码往往有自己的开发、修改、维护、调优的生命周期）。
限制数据作用域 两个线程修改对象的同一字段时可能会相互干扰，导致不可预期的行为，解决方案之一是构造临界区，但是必须限制临界区的数量。
使用数据副本 数据副本是避免共享数据的好方法，复制出来的对象只是以只读的方式对待。Java5的 java.util.concurrent 包中增加一个名为 CopyOnWriteArrayList 的类，它是 List 接口的子类型，所以你可以认为它是 ArrayList 的线程安全的版本，它使用了写时复制的方式创建数据副本进行操作来避免对共享数据并发访问而引发的问题。
Java5以前的并发编程 Java的线程模型建立在抢占式线程调度的基础上，也就是说：
 所有线程可以很容易的共享同一进程中的对象。 能够引用这些对象的任何线程都可以修改这些对象。 为了保护数据，对象可以被锁住。  Java基于线程和锁的并发过于底层，而且使用锁很多时候都是很万恶的，因为它相当于让所有的并发都变成了排队等待。
在Java 5以前，可以用synchronized关键字来实现锁的功能，它可以用在代码块和方法上，表示在执行整个代码块或方法之前线程必须取得合适的锁。对于类的非静态方法（成员方法）而言，这意味这要取得对象实例的锁，对于类的静态方法（类方法）而言，要取得类的Class对象的锁，对于同步代码块，程序员可以指定要取得的是那个对象的锁。
不管是同步代码块还是同步方法，每次只有一个线程可以进入，如果其他线程试图进入（不管是同一同步块还是不同的同步块），JVM会将它们挂起（放入到等锁池中）。这种结构在并发理论中称为临界区（critical section）。这里我们可以对Java中用synchronized实现同步和锁的功能做一个总结：
 只能锁定对象，不能锁定基本数据类型 被锁定的对象数组中的单个对象不会被锁定 同步方法可以视为包含整个方法的 synchronized(this) { … } 代码块 静态同步方法会锁定它的 Class 对象 内部类的同步是独立于外部类的 ** synchronized 修饰符并不是方法签名的组成部分，所以不能出现在接口的方法声明中** 非同步的方法不关心锁的状态，它们在同步方法运行时仍然可以得以运行 ** synchronized 实现的锁是可重入的锁**  在JVM内部，为了提高效率，同时运行的每个线程都会有它正在处理的数据的缓存副本，当我们使用 synchronzied 进行同步的时候，真正被同步的是在不同线程中表示被锁定对象的内存块（副本数据会保持和主内存的同步，现在知道为什么要用同步这个词汇了吧），简单的说就是在同步块或同步方法执行完后，对被锁定的对象做的任何修改要在释放锁之前写回到主内存中；在进入同步块得到锁之后，被锁定对象的数据是从主内存中读出来的，持有锁的线程的数据副本一定和主内存中的数据视图是同步的。</description>
    </item>
    
    <item>
      <title>LinkedList源码分析</title>
      <link>https://cuilan.github.io/posts/javase/linked-list-source-analysis/</link>
      <pubDate>Thu, 06 Dec 2018 23:10:05 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/linked-list-source-analysis/</guid>
      <description>一、LinkedList简介二、成员分析三、链表实现四、双端队列实现五、队列实现六、栈实现七、列表实现八、迭代器、分割器一、LinkedList简介 java.util.LinkedList 是 java.util.List 接口实现，是一个 链表 数据结构的实现，直接继承自 java.util.AbstractSequentialList 抽象有序集合，是一个有序的 List，同时实现了 java.util.List 、 java.util.Deque 接口，也具备 队列 、 双端队列 的功能。同时，LinkedList 也具有 栈 的数据结构。因此 LinkedList 可以满足多种使用场景，是一个功能齐全的集合。
1.1 LinkedList 继承关系图 1.2 LinkedList 的特性：  实现了 双链表 结构 实现了 Queue(队列) 与 Deque(双端队列) 结构 实现了 Stack(栈) 结构 有序 可重复 线程不安全 允许 null 值 查询慢、增删快 底层通过 Node 实现  1.3 线程同步问题 由于 LinkedList 出于性能的考虑，并没有实现同步，因此在多线程环境下操作时，可能会引发线程安全问题。最好的解决办法是在创建时使用集合工具类 Collections.synchronizedList() 方法进行包装，以防止意外对列表的非同步访问。
List list = Collections.synchronizedList(new LinkedList(...));  二、成员分析 2.1 成员变量 // 集合大小 transient int size = 0; /** * 指向第一个节点的指针 * Invariant: (first == null &amp;amp;&amp;amp; last == null) || * (first.</description>
    </item>
    
    <item>
      <title>ArrayList源码分析</title>
      <link>https://cuilan.github.io/posts/javase/array-list-source-analysis/</link>
      <pubDate>Thu, 15 Nov 2018 22:26:53 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/javase/array-list-source-analysis/</guid>
      <description>ArrayList应该算是日常开发中使用最多的List实现类。
一、ArrayList 的特性  有序 可重复 线程不安全 允许插入 null 值 查询快、增删慢 底层通过 Object[] 数组实现  二、ArrayList继承关系 java.util.ArrayList 继承 java.util.AbstractList，实现了 java.util.List、java.util.RandomAccess、 java.io.Serializable 接口。
 三、成员变量 // 序列化版本id private static final long serialVersionUID = 8683452581122892189L; // 默认初始容量 private static final int DEFAULT_CAPACITY = 10; // 用于空实例的共享空数组实例 private static final Object[] EMPTY_ELEMENTDATA = {}; // 用于默认大小的空实例的共享空数组实例。 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; // 存储 ArrayList 元素的数组缓冲区 transient Object[] elementData; // ArrayList 的大小 private int size; // ArrayList 最大容量 private static final int MAX_ARRAY_SIZE = Integer.</description>
    </item>
    
    <item>
      <title>七、理解GC日志</title>
      <link>https://cuilan.github.io/posts/jvm/jvm-gc-log/</link>
      <pubDate>Thu, 08 Nov 2018 15:13:38 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/jvm/jvm-gc-log/</guid>
      <description>每一种收集器的日志形式都是由它们自身的实现所决定的，换而言之，每个收集器的日志格式都可以不一样。但虚拟机设计者为了方便用户阅读，将各个收集器的日志都维持一定的共性，例如以下两段典型的GC日志：
33.125: [GC [DefNew: 3324K-&amp;gt;152K(3712K), 0.0025925 secs] 3324K-&amp;gt;152K(11904K), 0.0031680 secs] 100.667: [Full GC [Tenured: 0K-&amp;gt;210K(10240K), 0.0149142 secs] 4603K-&amp;gt;210K(19456K), [Perm : 2999K-&amp;gt;2999K(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs] 最前面的数字“33.125：”和“100.667：”代表了 GC发生的时间 ，这个数字的含义是 从Java虚拟机启动以来经过的秒数 。
GC日志开头的“ ［GC ”和“ ［Full GC ”说明了这次垃圾收集的停顿类型， 而不是用来区分新生代GC还是老年代GC的 。如果有“Full”，说明这次GC是发生了Stop-The-World的，例如下面这段新生代收集器ParNew的日志也会出现“［Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。 如果是调用System.gc()方法所触发的收集，那么在这里将显示“［Full GC (System)” 。
[Full GC 283.736: [ParNew: 261599K-&amp;gt;261599K(261952K), 0.0000288 secs] 接下来的“［ DefNew ”、“ ［Tenured ”、“ ［Perm ”表示 GC发生的区域 ， 这里显示的区域名称与使用的GC收集器是密切相关的 ，例如上面样例所使用的Serial收集器中的新生代名为“Default New Generation”，所以显示的是“［DefNew”。如果是ParNew收集器，新生代名称就会变为“［ParNew”，意为“Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。
后面方括号内部的“ 3324K-&amp;gt;152K(3712K) ”含义是“ GC前该内存区域已使用容量-&amp;gt; GC后该内存区域已使用容量 (该内存区域总容量) ”。而在方括号之外的“ 3324K-&amp;gt;152K(11904K) ”表示“ GC前Java堆已使用容量 -&amp;gt; GC后Java堆已使用容量 (Java堆总容量) ”。</description>
    </item>
    
    <item>
      <title>六、垃圾收集器</title>
      <link>https://cuilan.github.io/posts/jvm/jvm-garbage-collector/</link>
      <pubDate>Thu, 08 Nov 2018 15:12:57 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/jvm/jvm-garbage-collector/</guid>
      <description>收集算法是内存回收的方法论，而 垃圾收集器就是内存回收的具体实现 。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。这里讨论的收集器基于JDK 1.7 Update 14之后的HotSpot虚拟机（在这个版本中正式提供了商用的G1收集器，之前G1仍处于实验状态），这个虚拟机包含的所有收集器如所示。
上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器 。
Serial收集器 Serial收集器是最基本、发展历史最悠久的收集器 ，曾经（在JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。看名字就会知道， 这个收集器是一个单线程的收集器 ，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。“Stop The World”这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。下图示意了Serial / Serial Old收集器的运行过程。
对于“Stop The World”带给用户的不良体验，虚拟机的设计者们表示完全理解，但也表示非常委屈：“你妈妈在给你打扫房间的时候，肯定也会让你老老实实地在椅子上或者房间外待着，如果她一边打扫，你一边乱扔纸屑，这房间还能打扫完？”这确实是一个合情合理的矛盾，虽然垃圾收集这项工作听起来和打扫房间属于一个性质的，但实际上肯定还要比打扫房间复杂得多！
从JDK 1.3开始，一直到现在最新的JDK 1.7，HotSpot虚拟机开发团队为消除或者减少工作线程因内存回收而导致停顿的努力一直在进行着，从Serial收集器到Parallel收集器，再到Concurrent Mark Sweep（CMS）乃至GC收集器的最前沿成果Garbage First（G1）收集器，我们看到了一个个越来越优秀（也越来越复杂）的收集器的出现，用户线程的停顿时间在不断缩短，但是仍然没有办法完全消除（这里暂不包括RTSJ中的收集器）。寻找更优秀的垃圾收集器的工作仍在继续！
写到这里，笔者似乎已经把Serial收集器描述成一个“老而无用、食之无味弃之可惜”的鸡肋了，但实际上到现在为止，它依然是虚拟机运行在Client模式下的默认新生代收集器。它也有着优于其他收集器的地方： 简单而高效 （与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。
ParNew收集器 ParNew收集器其实就是Serial收集器的多线程版本 ，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、 -XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。ParNew收集器的工作过程如图所示。
ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处，但 它却是许多运行在Server模式下的虚拟机中首选的新生代收集器 ，其中有一个与性能无关但很重要的原因是，除了Serial收集器外， 目前只有它能与CMS收集器配合工作 。在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器——CMS收集器（Concurrent Mark Sweep，本节稍后将详细介绍这款收集器），这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作，用前面那个例子的话来说，就是做到了在你的妈妈打扫房间的时候你还能一边往地上扔纸屑。
不幸的是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。ParNew收集器也是使用-XX:+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX:+UseParNewGC选项来强制指定它。
ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时系统资源的有效利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多（譬如32个，现在CPU动辄就4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。
注意　从ParNew收集器开始，后面还会接触到几款并发和并行的收集器。在大家可能产生疑惑之前，有必要先解释两个名词：并发和并行。这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们可以解释如下。
  并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
  并发（Concurrent） ：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。
  Parallel Scavenge收集器 Parallel Scavenge收集器是一个新生代收集器 ，它也是使用复制算法的收集器，又是并行的多线程收集器……看上去和ParNew都一样，那它有什么特别之处呢？
Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即 吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间 ），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</description>
    </item>
    
    <item>
      <title>五、HotSpot的算法实现</title>
      <link>https://cuilan.github.io/posts/jvm/jvm-hotspot-algorithm/</link>
      <pubDate>Thu, 08 Nov 2018 14:24:45 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/jvm/jvm-hotspot-algorithm/</guid>
      <description>枚举根节点 以可达性分析中从GC Roots节点找引用链这个操作为例， 可作为GC Roots的节点主要在全局性的引用（如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中 ，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。 另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行——这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有Java执行线程（Sun将这件事情称为“Stop The World”）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。
目前的主流Java虚拟机使用的都是准确式GC，当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用 。在HotSpot的实现中，是使用一组称为OopMap（Ordinary Object Pointer）的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。
安全点 在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。
实际上，HotSpot也的确没有为每条指令都生成OopMap ，前面已经提到， 只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停 。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。
对于Sefepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来 。这里有两种方案可供选择： 抢先式中断 （Preemptive Suspension）和 主动式中断 （Voluntary Suspension），其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。 现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件 。
而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。
安全区域 使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却并不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候 线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决 。
安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。
在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止 。</description>
    </item>
    
    <item>
      <title>四、垃圾回收算法</title>
      <link>https://cuilan.github.io/posts/jvm/jvm-gc-algorithm/</link>
      <pubDate>Thu, 08 Nov 2018 12:14:26 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/jvm/jvm-gc-algorithm/</guid>
      <description>标记-清除算法 最基础的收集算法是“ 标记-清除 ”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段： 首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 ，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。标记—清除算法的执行过程如图所示。
复制算法 为了解决效率问题，一种称为“ 复制 ”（Copying）的收集算法出现了，它 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉 。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。复制算法的执行过程如图所示。
现在的商业虚拟机都采用这种收集算法来回收新生代 ，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1∶1的比例来划分内存空间， 而是将内存分为一块较大的Eden空间和两块较小的Survivor空间 ，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。 HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费” 。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行 分配担保 （Handle Promotion）。 如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代 。
标记-整理算法 复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况， 所以在老年代一般不能直接选用复制算法 。 根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如图所示。
分代收集算法 当前商业虚拟机的垃圾收集都采用“ 分代收集 ”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收 。</description>
    </item>
    
    <item>
      <title>三、垃圾收集器与内存分配策略</title>
      <link>https://cuilan.github.io/posts/jvm/jvm-gc-memory-strategy/</link>
      <pubDate>Wed, 07 Nov 2018 17:29:52 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/jvm/jvm-gc-memory-strategy/</guid>
      <description>1、概述 第一门正真使用内存动态分配和垃圾回收技术的语言是Lisp语言。
在Java各内存区域中，程序计数器、虚拟机栈、本地方法区3个区域随线程而生，随线程而灭，这几个区域的内存分配和垃圾回收都具有确定性 ，这几个区域内就不需要过多的考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。我们只需要考虑Java堆和方法区中的内存即可。
2、对象回收算法 引用计数算法 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，引用器值就减1；任何时刻计数器为0点对象就是不可能再被使用的。
但至少主流的Java虚拟机里没有选用引用计数算法来管理内存 ，其中最主要的原因是它很难解决对象之间相互循环引用的问题。
可达性分析算法 在主流的商用程序语言 （Java、C#，甚至包括前面提到的古老的Lisp）的主流实现中， 都是称通过可达性分析（Reachability Analysis）来判定对象是否存活的 。这个算法的基本思路就是通过一系列的称为“ GC Roots ”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为 引用链 （Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。如图所示，对象object 5、object 6、object 7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。
在Java语言中，可作为GC Roots的对象包括下面几种：  虚拟机栈（栈帧中的本地变量表）中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI（即一般说的Native方法）引用的对象。  对象的四种引用 无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“ 引用 ”有关。在JDK 1.2以前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。
在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱 。
强引用就是指在程序代码之中普遍存在的， 类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象 。
软引用是用来描述一些 还有用但并非必需的对象 。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。
弱引用也是用来描述 非必需对象 的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。
虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例 。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。
对象回收时的自我拯救 即使在可达性分析算法中不可达的对象，也并非是“非死不可”的 ，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程： 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行” 。</description>
    </item>
    
    <item>
      <title>二、HotSpot虚拟机对象模型</title>
      <link>https://cuilan.github.io/posts/jvm/jvm-object-model/</link>
      <pubDate>Wed, 07 Nov 2018 16:35:23 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/jvm/jvm-object-model/</guid>
      <description>虚拟机内部细节，各虚拟机厂商的实现略有差异，因此以主流的Oracle HotSpot虚拟机为例分析。
1、对象的创建 Java是一门面向对象的编程语言，在语言层面上，创建对象（例如克隆，反序列化）通常仅仅是一个new关键字而已，而在虚拟机中，对象（进限于普通Java对象，不包括数组和Class对象等）的创建过程为：
加载相应的类 ：当虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用的类是否已被加载、解析和初始化过。如果没有，则必须先执行响应的类的加载过程。
分配内存 ：对象所需内存的大小在类加载完成后便可完全确定。此过程等同于为把一块确定大小的内存从Java堆中划分出来。划分方法主要有 指针碰撞 和 空闲列表 两种分配方式，而选择哪种方式由Java堆内存是否规整决定，Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
a、指针碰撞 如果java堆中内存是绝对规整的，所有用过的内存都放在一边，未使用的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针指向空闲空间那边挪动一段与对象大小相等的距离。
b、空闲列表 如果java堆中的内存并不是规整的，已使用的内存和未使用的内存相互交错，就无法使用指针碰撞了，虚拟机必须维护一个列表来记录哪些内存是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新表上的记录。
后续工作 ：内存分配完成后，虚拟机需要将分配到的内存空间初始化为零值(不包括对象头)，然后再对对象进行必要的设置（主要是对象头信息的设置）。此时，在虚拟机看来一个新的对象已经产生了，但是从程序员的角度来看，对象创建才刚刚开始，需要执行方法，把对象按照程序员的意愿进行初始化。
2、对象的内存划分 在HotSpot虚拟机中，对象在内存中存储的布局分为3块区域： 对象头 （Header）、 实例数据 （Instance Data）和 对齐填充 （Padding）。
对象头信息： 包括两部分信息（平均分配），第一部分用于存储对象自身的运行时数据，如哈希吗、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称为“Mark Work”。对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。
实例数据： 是对象真正的存储的有效信息，也是在程序中所定义的各种类型的字段内容。无论是从父类中继承下来的，还是在子类中定义的，都需要记录下来。 存储顺序会受到分配策略参数和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oop（Ordinary Object Pointers），相同宽度的字段总是被分配到一起。在满足这个前提条件下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。
对齐填充： 并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用。而HotSpot VM的自动内存管理系统要求对象的大小必须是8字节的整数倍。对象头部分正好是8字节的倍数（1倍或者2倍），因此当对象实例数据部分没有对齐时，就需要对齐填充来补充。
3、对象的访问定位 Java程序需要通过栈上的引用数据来操作堆上的具体对象 。对象的访问方式取决于虚拟机实现，目前主流的访问方式有使用句柄和直接指针两种。
句柄： 可以理解为指向指针的指针（句柄池，也在堆中），维护指向对象的指针变化，而对象的句柄本身不发生变化。
优势 ：引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。
指针： 指向对象，代表对象的内存地址。如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 引用中存储的直接就是对象地址 。
优势 ：速度更快，节省了一次指针定位的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。
HotSpot虚拟机使用第二种方式进行对象访问。</description>
    </item>
    
    <item>
      <title>一、Java内存区域与内存溢出异常</title>
      <link>https://cuilan.github.io/posts/jvm/jvm-memory-exceptions/</link>
      <pubDate>Wed, 07 Nov 2018 15:37:29 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/jvm/jvm-memory-exceptions/</guid>
      <description>1、概述 Java虚拟机自动内存管理机制，不需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄露和内存溢出的问题，由虚拟机管理着一切。
2、运行时数据区域 程序计数器（线程私有） 程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器，字节码解释器在工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
Java虚拟机栈（线程私有） 生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型；每个方法在执行的时候会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中入栈（压栈）到出栈（弹栈）的过程。 局部变量表 存放了编译期可知的各种 基本数据类型 （byte、short、int、long、boolean、float、double、char）、 对象引用 （ reference类型 （不同于对象本身，可能是一个指向对象其实地址的引用指针，也可能是一个代表对象的句柄或其他与此对象相关的位置）、 returnAddress类型 （指向了一条字节码执行的地址））。其中64位长度的long、double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占1个。 局部变量表所需的内存空间在编译期间完成分配，进入一个方法时，需要在栈帧中分配多大的内存是完全确定的，在方法运行期间不会改变局部变量表的大小 。 在Java虚拟机规范中，对此区域规定了两种异常状况： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常 ；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可以动态扩展，只不过Java虚拟机Java虚拟机规范中也允许固定长度的虚拟机栈）， 如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常 。
本地方法栈 本地方法栈与虚拟机栈的作用非常相似，区别：虚拟机栈是为执行Java方法（字节码）服务， 本地方法栈则为虚拟机使用到的Native方法服务 。 本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常 。注意：在HotSpot虚拟机中本地方法栈和虚拟机栈合二为一。
Java堆（Java Heap） Java堆是Java虚拟机所管理的内存中最大的一块。堆内存被所有的线程共享，在虚拟机启动时创建，此区域唯一的目的就是为了存放对象实例，几乎所有的对象实例都在这里分配内存。在Java虚拟机规范中的描述是： 所有的对象实例及数组都要在堆上分配 。 Java堆是垃圾收集器管理的主要区域（因此也叫：GC堆）。由于现在收集器基本都采用分带收集算法，所以Java堆中还可以细分为： 新生代和年老代 ，再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。 从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。 根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现上，堆内存既可以是固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出outOfMemoryError异常 。
方法区（Method Area） 与堆一样，是各个线程共享的内存区域， 用于存储已被虚拟机加载的类信息、异常、静态变量、即时编译器编译后的代码等数据 。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但它的别名叫 Non-Heap（非堆） ，目的是与Java堆分开。 在HotSpot虚拟机中，方法区也被叫做“永久代”，但本质上两者并不等价， 在JDK8之后HotSpot取消了永久代，引入了元空间的内存管理机制。在JDK7中，已经把原本放在永久代的字符串常量池移出 。 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常 。
运行时常量池 运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的 版本信息、字段、方法、接口等描述信息 外，还有一项信息是常量池， 用于存放编译器生成的各种字面量和字符号引用 ，这部分内容将在类加载后进入方法区的运行时常量池中存放。 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，即并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，如：String类的intern()方法。 同方法区一样，当无法申请到新的内存时，会抛出OutOfMemoryError异常 。</description>
    </item>
    
  </channel>
</rss>