<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>多线程 on 翠兰 - Greenland</title>
    <link>https://cuilan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
    <description>Recent content in 多线程 on 翠兰 - Greenland</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 19 Sep 2019 12:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://cuilan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java中的锁-AbstractQueuedSynchronizer队列同步器</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E4%B8%AD%E7%9A%84%E9%94%81%E4%BA%8C/</link>
      <pubDate>Thu, 19 Sep 2019 12:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E4%B8%AD%E7%9A%84%E9%94%81%E4%BA%8C/</guid>
      <description>AbstractQueuedSynchronizer 同步器提供了一个框架，用于构建 先进先出(FIFO) 等待队列的 阻塞锁 和 相关同步器（信号量，事件等）。它使用了一个 int 成员变量表示同步状态，通过 FIFO 队列来完成资源获取线程的排队工作。
一、同步器的使用  同步器的主要使用方式是 继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。 使用同步器提供的3个方法：getState()，setState(int newState) 和 compareAndSetState(int expect, int update) 进行操作，因为以上方法可以保证状态的改变是安全的。 子类应定义为非公共的静态内部类。  访问或修改同步状态的3个方法 源码中这三个方法都被定义为 final，子类不可以重写。
 getState()：获取当前同步状态。 setState(int newState)：设置当前同步状态。 compareAndSetState(int expect, int update)：使用 CAS 设置当前状态，该方法能保证状态设置的原子性。   二、独占模式和共享模式 AbstractQueuedSynchronizer 支持 独占模式（默认） 和 共享模式 两种。
 独占模式下，当一个线程获取到锁，其他线程只能处于同步队列中等待，只有获取到锁的线程释放了锁，其他线程才能获取锁。 共享模式下，多个线程可以同时获取锁，并发的访问资源，如：ReadWriteLock。  通常，子类实现仅支持其中的一种模式，但在 ReadWriteLock 读写锁中两种模式都可以发挥作用。
2.1 同步器可重写的方法 仅支持独占模式的子类无需重写：tryAcquireShared()、tryReleaseShared() 方法。 仅支持共享模式的子类无需重写：tryAcquire()、tryRelease() 方法。
   方法名称 功能描述     boolean tryAcquire(int arg) 独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态十分符合预期，然后进行CAS设置同步状态。   boolean tryRelease(int arg) 独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态。   int tryAcquireShared(int arg) 共享式获取同步状态，返回大于等于0的值，表示获取成功，反之，获取失败。   boolean tryReleaseShared(int arg) 共享式释放同步状态。   boolean isHeldExclusively() 当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所占有。    2.</description>
    </item>
    
    <item>
      <title>Java并发编程目录</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Tue, 17 Sep 2019 23:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9B%AE%E5%BD%95/</guid>
      <description>Java并发机制的底层实现原理（volatile）Java并发机制的底层实现原理（synchronized）Java并发机制的底层实现原理（原子操作）Java内存模型一（基础）Java内存模型二（重排序）Java内存模型三（顺序一致性）Java内存模型四（volatile内存语义）Java中的锁（Lock接口）</description>
    </item>
    
    <item>
      <title>Java中的锁（Lock接口）</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E4%B8%AD%E7%9A%84%E9%94%81%E4%B8%80/</link>
      <pubDate>Tue, 09 Jul 2019 19:39:01 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E4%B8%AD%E7%9A%84%E9%94%81%E4%B8%80/</guid>
      <description>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，如：读写锁）。
在Lock接口出现之前，Java程序依靠 synchronized 关键字实现锁的功能。
Java1.5之后，并发包中新增了 Lock 接口（以及相关实现类）用来实现锁功能，它提供了与 synchronized 关键字类似的同步功能，只是使用时需要显示地获取和释放锁。
Lock接口优缺点对比： 优点：拥有锁获取与释放锁的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。
缺点：缺少了（通过synchronized块或方法锁提供的）隐式获取、释放锁的便捷性。
synchronized 关键字会隐式地获取锁，但是它将锁的获取和释放固化了，也就是先获取再释放，但同时，这种方式简化了同步的管理。
 Lock的使用 Lock lock = new ReentranLock(); lock.lock(); try { } finally { lock.unlock(); } 在finally块中释放锁，目的是保证在获取到锁之后，最终能被释放。
注意：不要将获取锁的过程卸载try块中，因为如果在获取锁（自定义实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。
 Lock接口API // 获取锁，调用该方法当前线程将会获取锁，当锁获得后，从该方法返回。 void lock(); // 可中断地获取锁，和 lock() 方法的不同之处在于该方法会响应中断，即在锁的获取中可以中断当前线程。 void lockInterruptibly() throws InterruptedException; // 尝试非阻塞的获取锁，调用该方法后立刻返回，如果能够获取则返回 true，否则返回 false。 boolean tryLock(); /** * 超时的获取锁，当前线程在以下3种情况下会返回： * 1. 当前线程在超时时间内获得了锁。 * 2. 当前线程在超时时间内被中断。 * 3. 超时时间结束，返回 false。 */ boolean tryLock(long time, TimeUnit unit) throws InterruptedException; // 释放锁。 void unlock(); // 获取等待通知组件，该组件和当前的锁绑定， // 当前线程只有获得了锁，才能调用该组件的 wait() 方法， // 而调用后，当前线程将被释放锁。 Condition newCondition(); </description>
    </item>
    
    <item>
      <title>Java内存模型四（volatile内存语义）</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9B%9B/</link>
      <pubDate>Thu, 30 May 2019 23:35:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9B%9B/</guid>
      <description>1、volatile的特性  可见性：对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。 原子性：对任意单个 volatile 变量的读/写具有原子性，但类似于 volatile++ 这种复合操作不具有原子性。  2、volatile写-读建立的happens-before关系 从 JSR-133 开始（JDK5），volatile 变量的写-读可以实现线程之间的通信。
从内存语义的角度来说，volatile 的读-写与锁的释放-获取有相同的内存效果：volatile 写和锁的释放有相同的内存语义；volatile 读和锁的获取有相同的内存语义。
volatile 变量示例：
class VolatileExample { private int a = 0; private volatile boolean flag = false; public void writer() { a = 1; // 1  flag = true; // 2  } public void reader() { if (flag) { // 3  int i = a; // 4  } } } 根据 happens-before 规则：</description>
    </item>
    
    <item>
      <title>Java内存模型三（顺序一致性）</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%89/</link>
      <pubDate>Wed, 29 May 2019 23:37:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%89/</guid>
      <description>顺序一致性内存模型 是一个理论参考模型。处理器的内存模型 和 编程语言的内存模型 都会以其作为参考。
1、数据竞争与顺序一致性 Java内存模型规范对 数据竞争 的定义：
 在一个线程中写一个变量 在另一个线程读同一个变量 而且写和读没有通过同步来排序  如果一个多线程程序能正确同步，则这个程序将是一个没有数据竞争的程序。
JMM对正确同步的多线程程序的内存一致性做了如下保证：
如果程序是正确同步的，程序的执行将具有顺序一致性，即：程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。
2、顺序一致性内存模型 &amp;amp; JMM（Java内存模型） 顺序一致性内存模型的特点：
   一个线程中的所有操作必须按照程序的顺序来执行。    不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。    注意：JMM中不保证每个操作立即对所有线程可见。
未同步程序在 JMM 中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。
JMM 的具体实现原则：在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器提供优化。
3、未同步程序的执行特性 对于未同步或未正确同步的多线程程序，JMM 只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值(0, null, false)，JMM 保证线程读操作读取到值不会凭空产生。
未同步程序在两个模型中执行的差异：
   顺序一致性模型保证单线程内的操作会按程序的顺序执行，而 JMM 不保证单线程内的操作会按程序的顺序执行。    顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而 JMM 不保证所有线程能看到一致的操作执行顺序。    JMM 不保证对64位的 long 型和 double 型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。    Java语言规范鼓励但不强求 JVM 对64位的 long 型和 double 型变量的写操作具有原子性。从 JSR-133 内存模型（JDK5）开始，仅仅只允许把一个64位 long/double型变量的写操作拆分为两个32位的写操作来执行，任何读操作在 JSR-133 中都必须具有原子性。</description>
    </item>
    
    <item>
      <title>Java内存模型二（重排序）</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BA%8C/</link>
      <pubDate>Mon, 27 May 2019 23:33:46 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BA%8C/</guid>
      <description>重排序：指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。
1、数据依赖性 如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。
数据依赖性分为下列3种：
   名 称 代码示例 说 明     写后读 a = 1; b = a; 写一个变量之后，再读这个变量   写后写 a = 1; a = 2; 写一个变量之后，在写这个变量   读后写 a = b; b = 1; 读一个变量之后，再写这个变量    以上3种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。
编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。
注意：数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。
2、as-if-serial语义 as-if-serial 语义的意思是：不管怎样重排序，单线程程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。
as-if-serial 语义使单线程程序不会发生因重排序而导致的线程安全问题，也无需担心内存可见性问题。
3、程序顺序规则 如果：
// 求圆的面积 	double pi = 3.14;	// A 	double r = 1.</description>
    </item>
    
    <item>
      <title>Java内存模型一（基础）</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%80/</link>
      <pubDate>Wed, 22 May 2019 22:26:01 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%80/</guid>
      <description>Java内存模型的基础：主要介绍内存模型相关的基本概念 Java内存模型中的顺序一致性：主要介绍 重排序 与 顺序一致性内存模型 同步原语：主要介绍3个同步原语 (synchronized、volatile、final) 的内存语义及重排序规则在处理器中的实现 Java内存模型的设计：主要介绍Java内存模型的设计原理，及其余处理器内存模型和顺序一致性内存模型的关系  1、并发编程模型的两个关键问题 在命令式编程中，线程之间的通信机制有两种：共享内存、消息传递
线程之间如何通信 通信：指线程之间以何种机制来交换信息。
 共享内存 并发模型中：线程间共享程序的公共状态，通过读 - 写内存中的公共状态进行隐式通信。 消息传递 并发模型中：线程间没有公共状态，必须通过发生消息来显式进行通信。  线程之间如何同步 同步：指程序中用于控制不同线程间操作发生的相对顺序的机制。
 **共享内存 **并发模型中：同步是显式进行的。程序员必须显式指定代码需要在线程间互斥执行。 **消息传递 **并发模型中：由于消息的发送必须在消息的接受之前，因此同步是隐式进行的。  Java的并发采用的是共享内存模型 Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。
2、Java内存模型(JMM)的抽象结构  共享变量（所有实例域、静态域、数组元素）都存储在堆内存中，堆内存在线程之间共享。 局部变量、方法定义参数、异常处理器参数，不会在线程之间共享，也不会有内存可见性问题，不受内存模型影响。  JMM决定一个线程对共享变量的写入何时对另一个线程可见。
JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中；每个线程都有一个私有的本地内存，本地内存中存储了该线程以读-写共享变量的副本。
JMM通过控制主内存与每个线程的本地内存之间的交互，来保证Java的内存可见性。
3、从源代码到指令序列的重排序 重排序分为3种：  编译器优化重排序：属于编译器重排序 指令级并行重排序：属于处理器重排序 内存系统重排序：属于处理器重排序  编译Java源代码经历的重排序顺序：Java源代码 -&amp;gt; 编译器优化重排序 -&amp;gt; 指令级并行重排序 -&amp;gt; 内存系统重排序 -&amp;gt; 最终执行的指令序列
防止重排序可能导致多线程内存可见性问题  对于编译器重排序：JMM的编译器重排序规则会禁止特定类型的编译器重排序（非所有编译器重排序都要禁止）。 对于处理器重排序：JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障，来禁止特定类型的处理器重排序。  JMM属于语言级别的内存模型，它保证不同的编译器和不同的处理器平台上，通过禁止特定类型的编译器重排序和处理器重排序，提供一致的内存可见性保证。
4、内存屏障的分类 内存屏障类型表：
   屏障类型 指令实例 说明     LoadLoad Barriers Load1;LoadLoad;Load2 确保Load1数据的装载先于Load2及所有后续装载指令的装载   StoreStore Barriers Store1;StoreStore;Store2 确保Store1数据对其他处理器可见先于Load2及所有后续存储指令的存储   LoadStore Barriers Load1;LoadStore;Store 确保Load1数据的装载先于Store2及所有后续存储指令刷新到内存   StoreLoad Barriers Store1;StoreLoad;Load2 确保Store1数据对其他处理器变得可见，先于Load2及所有后续存储指令的存储    StoreLoad Barriers 是一个“全能型”的屏障，此指令会使该屏障之前的所有内存访问指令完成之后，才执行该屏障之后的内存访问指令。因此执行该屏障的开销会很昂贵。</description>
    </item>
    
    <item>
      <title>Java并发机制的底层实现原理（原子操作）</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%89/</link>
      <pubDate>Mon, 01 Apr 2019 22:29:11 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%89/</guid>
      <description>原子操作：不可被中断的一个或一系列操作。
一、处理器如何实现原子操作 使用总线锁保证原子性 第一个机制是通过总线锁保证原子性。如果多个处理器同时对共享变量进行读改写操作（i++就是经典的读改写操作），那么共享变量就会被多个处理器同时进行操作，这样的操作就不是原子的。
要想保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。
处理器使用 总线锁 来解决这个问题。
总线锁：就是使用处理器通过的一个 LOCK # 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。
使用缓存锁保证原子性 第二个机制是通过缓存锁定来保证原子性。在同一时刻，只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这期间其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大。
缓存锁定：指内存区域如果被缓存在处理器的缓存行中，并且在 Lock 操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言 LOCK # 信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性。因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写到已被锁定的缓存行的数据时，会使缓存无效。
但是有两种情况下处理器不会使用缓存锁定：
 当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线锁定。 有些处理器不支持缓存锁定。   二、Java如何实现原子操作 在Java中可以通过 锁 和 循环CAS 的方式来实现原子操作。
使用循环CAS实现原子操作 从Java1.5开始，JDK的并发包提供了一些类来支持原子操作：
 AtomicBoolean: 用原子方式更新boolean值 AtomicInteger: 用原子方式更新int值 AtomicLong: 用原子方式更新long值 &amp;hellip;&amp;hellip;  CAS实现原子操作的三大问题  ABA问题：JDK的 Atomic包 里 AtomicStampedReference 来解决ABA问题。 循环时间长开销大 只能保证一个共享变量的原子操作：AtomicReference 来保证引用对象之间的原子性，把多个变量放在一个对象里进行CAS操作。  使用锁机制实现原子性 锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了多种锁机制，有偏向锁、轻量级锁和互斥锁。除了偏向锁，JVM实现锁的方式都用了循环CAS。即当一个线程想进入同步块的时候使用循环CAS的方式来获得锁，当它想退出同步块的时候使用循环CAS释放锁。</description>
    </item>
    
    <item>
      <title>Java并发机制的底层实现原理（synchronized）</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BA%8C/</link>
      <pubDate>Thu, 21 Mar 2019 00:16:03 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BA%8C/</guid>
      <description>synchronized 一般称之为重量级锁，在Java1.6中对 synchronized 进行了各种优化，在有些情况下它并不那么重了。
利用synchronized实现同步的基础 在Java中每一个对象都可以作为锁。具体有以下3中形式：
 对于普通同步方法，锁是当前实例对象。 对于静态同步方法，锁是当前类的 Class 对象。 对于同步方法块，锁是 synchronized 括号里配置的对象。  当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。
 Java对象头 synchronized 用的锁是存储在Java对象头里的。如果对象是数组类型，则虚拟机用3个**字宽（Word）**存储对象头，如果是非数组对象类型，则用2个字宽存储对象头。
关于Java对象头，参见：Java对象头详解
Java对象头里的 Mark Word 里默认存储对象的 HashCode、分代年龄、是否是偏向锁 和 锁标志位。32位JVM的 Mark Word的默认存储结构如下：
   锁状态 25bit 4bit 1bit是否是偏向锁 2bit锁标志位     无锁状态 对象的hashCode值 对象分代年龄 0 01   无锁状态 线程ID、Epoch 对象分代年龄 1 01     锁的升级与对比 从Java1.6开始，为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”、“轻量级锁”。共有4中状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态 和 重量级锁状态，状态随着竞争激烈逐渐升级。
1.偏向锁 偏向锁的获得
当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程进入和退出同步块时不需要进行 CAS 操作来加锁和解锁，只需简单地测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁。如果存储，则表示线程已经获得了锁。如果没有存储，则需要再测试一下 Mark Word 中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用 CAS 竞争锁；如果已设置，则尝试使用 CAS 将对象头的偏向锁指向当前线程。</description>
    </item>
    
    <item>
      <title>Java并发机制的底层实现原理（volatile）</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%80/</link>
      <pubDate>Tue, 05 Mar 2019 23:20:27 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%80/</guid>
      <description>Java中所使用的并发机制依赖于JVM的实现和CPU的指令。在多线程并发编程中 synchronized 和 volatile 都扮演着重要的角色。
volatile的应用 volatile 是轻量级的 synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。 如果volatile变量修饰符使用适当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。
volatile的定义与实现原理 定义： Java编程语言允许线程访问共享变量，为了确保贡献变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。 如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。
volatile的使用场景 1.防止重排序
如在并发环境下的单例模式中，可以使用 volatile 关键字来防止编译时的指令重排。
public class Singleton { public static volatile Singleton singleton; /** * 私有化构造函数，防止外部调用实例化 */ private Singleton() { } public static Singleton getInstance() { if (singleton == null) { synchronized (singleton) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } JVM实例化一个对象的过程分为三个步骤：
 分配内存空间 初始化对象 将内存空间的地址赋值给对象的引用  但由于指令的重排，在多线程的场景下，可能会先将内存空间的地址值赋值给对象的引用，然后才实例化对象。这种情况会将一个未实例化的对象引用暴露出去，因此成员变量singleton被volatile关键字修饰，并在实例化时进行双重检查加锁（Double-Checked Lock）来保证单例对象的唯一性。</description>
    </item>
    
    <item>
      <title>Java并发解决方案</title>
      <link>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Mon, 04 Mar 2019 23:11:08 +0000</pubDate>
      
      <guid>https://cuilan.github.io/posts/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description>Java并发编程的缺陷
 上下文切换带来的CPU开销 死锁 物理硬件的限制 软件资源的限制  为什么需要并发？ 并发其实是一种解耦合的策略，这种策略帮助我们把做什么（目标）和什么时候做（时机）分开。优点是可以明显改进应用程序的吞吐量（获得更多的CPU调度时间）和结构（程序有多个部分在协同工作）。Servlet容器就是采用单实例多线程的工作模式，来处理并发问题。
误解和正解 误解：  并发总能改进性能 编写并发程序无序修改原有的设计 在试验Web或Spring容器时不用关注并发问题  正解：  编写并发程序会在代码上增加额外的开销 正确的并发是非常复杂的没及时对于很简单的问题 并发中的缺陷因为不易重现也不容易被发现 并发往往需要对设计策略从根本上进行修改  并发编程的原则和技巧 单一职责原则 分离并发相关代码和其他代码（并发相关代码往往有自己的开发、修改、维护、调优的生命周期）。
限制数据作用域 两个线程修改对象的同一字段时可能会相互干扰，导致不可预期的行为，解决方案之一是构造临界区，但是必须限制临界区的数量。
使用数据副本 数据副本是避免共享数据的好方法，复制出来的对象只是以只读的方式对待。Java5的 java.util.concurrent 包中增加一个名为 CopyOnWriteArrayList 的类，它是 List 接口的子类型，所以你可以认为它是 ArrayList 的线程安全的版本，它使用了写时复制的方式创建数据副本进行操作来避免对共享数据并发访问而引发的问题。
Java5以前的并发编程 Java的线程模型建立在抢占式线程调度的基础上，也就是说：
 所有线程可以很容易的共享同一进程中的对象。 能够引用这些对象的任何线程都可以修改这些对象。 为了保护数据，对象可以被锁住。  Java基于线程和锁的并发过于底层，而且使用锁很多时候都是很万恶的，因为它相当于让所有的并发都变成了排队等待。
在Java 5以前，可以用synchronized关键字来实现锁的功能，它可以用在代码块和方法上，表示在执行整个代码块或方法之前线程必须取得合适的锁。对于类的非静态方法（成员方法）而言，这意味这要取得对象实例的锁，对于类的静态方法（类方法）而言，要取得类的Class对象的锁，对于同步代码块，程序员可以指定要取得的是那个对象的锁。
不管是同步代码块还是同步方法，每次只有一个线程可以进入，如果其他线程试图进入（不管是同一同步块还是不同的同步块），JVM会将它们挂起（放入到等锁池中）。这种结构在并发理论中称为临界区（critical section）。这里我们可以对Java中用synchronized实现同步和锁的功能做一个总结：
 只能锁定对象，不能锁定基本数据类型 被锁定的对象数组中的单个对象不会被锁定 同步方法可以视为包含整个方法的 synchronized(this) { … } 代码块 静态同步方法会锁定它的 Class 对象 内部类的同步是独立于外部类的 ** synchronized 修饰符并不是方法签名的组成部分，所以不能出现在接口的方法声明中** 非同步的方法不关心锁的状态，它们在同步方法运行时仍然可以得以运行 ** synchronized 实现的锁是可重入的锁**  在JVM内部，为了提高效率，同时运行的每个线程都会有它正在处理的数据的缓存副本，当我们使用 synchronzied 进行同步的时候，真正被同步的是在不同线程中表示被锁定对象的内存块（副本数据会保持和主内存的同步，现在知道为什么要用同步这个词汇了吧），简单的说就是在同步块或同步方法执行完后，对被锁定的对象做的任何修改要在释放锁之前写回到主内存中；在进入同步块得到锁之后，被锁定对象的数据是从主内存中读出来的，持有锁的线程的数据副本一定和主内存中的数据视图是同步的。</description>
    </item>
    
  </channel>
</rss>