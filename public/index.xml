<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CUILAN</title>
    <link>https://cuilan.github.io/</link>
    <description>Recent content on CUILAN</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 04 Sep 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://cuilan.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Welcome to Zhaohuabing Blog</title>
      <link>https://cuilan.github.io/2020/09/04/hello-world/</link>
      <pubDate>Fri, 04 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/2020/09/04/hello-world/</guid>
      <description>“Yeah It&amp;rsquo;s on. ” Hello World!</description>
    </item>
    
    <item>
      <title>3.SpringMVC的请求如何分发？</title>
      <link>https://cuilan.github.io/post/spring/springmvc/springmvc-03/</link>
      <pubDate>Thu, 14 Nov 2019 15:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/spring/springmvc/springmvc-03/</guid>
      <description></description>
    </item>
    
    <item>
      <title>2.SpringMVC核心分发器DispatcherServlet分析</title>
      <link>https://cuilan.github.io/post/spring/springmvc/springmvc-02/</link>
      <pubDate>Mon, 04 Nov 2019 15:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/spring/springmvc/springmvc-02/</guid>
      <description>一、SpringMVC入口 SpringMVC启动类为：org.springframework.web.servlet.DispatcherS</description>
    </item>
    
    <item>
      <title>1.SpringMVC使用示例</title>
      <link>https://cuilan.github.io/post/spring/springmvc/springmvc-01/</link>
      <pubDate>Wed, 30 Oct 2019 12:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/spring/springmvc/springmvc-01/</guid>
      <description>SpringMVC项目的演示示例，包含 maven 依赖配置，web.xml 文件配置，spring-mvc.xml 文件配置等，代码部分省略。 创建mave</description>
    </item>
    
    <item>
      <title>SpringMVC目录</title>
      <link>https://cuilan.github.io/post/spring/springmvc/springmvc/</link>
      <pubDate>Tue, 29 Oct 2019 12:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/spring/springmvc/springmvc/</guid>
      <description>目录 1.SpringMVC使用示例 2.SpringMVC核心分发器DispatcherServlet分析 3.SpringMVC的请求如何分发</description>
    </item>
    
    <item>
      <title>Go环境搭建</title>
      <link>https://cuilan.github.io/post/go/go%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Wed, 16 Oct 2019 15:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/go/go%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>Go开发环境 下载并安装Go开发包 Go语言开发包：https://golang.org/ 安装并配置环境变量 # go语言安装路径 GOROOT=C:\Go\ # 修改gopat</description>
    </item>
    
    <item>
      <title>Java中的锁-AbstractQueuedSynchronizer队列同步器</title>
      <link>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E4%B8%AD%E7%9A%84%E9%94%81%E4%BA%8C/</link>
      <pubDate>Thu, 19 Sep 2019 12:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E4%B8%AD%E7%9A%84%E9%94%81%E4%BA%8C/</guid>
      <description>AbstractQueuedSynchronizer 同步器提供了一个框架，用于构建 先进先出(FIFO) 等待队列的 阻塞锁 和 相关同步器（信号量，事件等）。它使用了一个 int 成员变量表示同步状态，通过</description>
    </item>
    
    <item>
      <title>Java并发编程目录</title>
      <link>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Tue, 17 Sep 2019 23:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9B%AE%E5%BD%95/</guid>
      <description>目录 Java并发解决方案 Java并发机制的底层实现原理（volatile） Java并发机制的底层实现原理（synchronized） Java</description>
    </item>
    
    <item>
      <title>Dictionary抽象类源码分析</title>
      <link>https://cuilan.github.io/post/java/dictionary-source-analysis/</link>
      <pubDate>Tue, 17 Sep 2019 16:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/dictionary-source-analysis/</guid>
      <description>一、Dictionary特点或规范 Dictionary 抽象类形式上等同于一个接口，其全部方法都是抽象方法。它是 Hashtable 的父类，它将 键 映射到 值。每个键和每个值都是一个</description>
    </item>
    
    <item>
      <title>TreeMap源码分析</title>
      <link>https://cuilan.github.io/post/java/treemap-source-analysis/</link>
      <pubDate>Tue, 17 Sep 2019 12:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/treemap-source-analysis/</guid>
      <description>java.util.TreeMap 类继承了 java.util.AbstractMap 抽象类，实现了 java.util.NavigableMap、java.lang.Cloneable、java.io.Serial</description>
    </item>
    
    <item>
      <title>LinkedHashMap源码分析</title>
      <link>https://cuilan.github.io/post/java/linkedhashmap-source-analysis/</link>
      <pubDate>Sun, 15 Sep 2019 01:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/linkedhashmap-source-analysis/</guid>
      <description>java.util.LinkedHashMap 类继承了 java.util.HashMap 类，实现了 java.util.Map 接口。 LinkedHashMap继承关系 一、LinkedHashMap特点或规范 1.1 特点 java.util.LinkedHashMap 是 java.util.Map 接口的 链表 + 哈希 实现，具</description>
    </item>
    
    <item>
      <title>HashMap.TreeNode类源码分析</title>
      <link>https://cuilan.github.io/post/java/hashmap-treenode/</link>
      <pubDate>Wed, 11 Sep 2019 17:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/hashmap-treenode/</guid>
      <description>继承关系： java.util.Map.Entry Map 接口中的顶层实体接口。 java.util.HashMap.Node HashMap 中的单向链表节点。 java.util.LinkedHashMap.Entry LinkedHashMap 中的双向链表节点。 java.util.HashMap.TreeNode HashMap 中的红黑树节点。 TreeNode继承关系 一、HashMa</description>
    </item>
    
    <item>
      <title>HashMap源码分析</title>
      <link>https://cuilan.github.io/post/java/hashmap-source-analysis/</link>
      <pubDate>Tue, 03 Sep 2019 17:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/hashmap-source-analysis/</guid>
      <description>java.util.HashMap 类继承了 java.util.AbstractMap 抽象类，实现了 java.util.Map、java.lang.Cloneable、java.io.Serializable 接口。</description>
    </item>
    
    <item>
      <title>AbstractMap源码分析</title>
      <link>https://cuilan.github.io/post/java/abstractmap-source-analysis/</link>
      <pubDate>Mon, 02 Sep 2019 17:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/abstractmap-source-analysis/</guid>
      <description>java.util.AbstractMap 抽象类实现了 java.util.Map 接口。 AbstractMap接口继承关系 一、AbstractMap特点或规范 AbstractMap 抽象类提供了 Map 接口的基础实现，以最大限度地减少</description>
    </item>
    
    <item>
      <title>NavigableMap接口源码分析</title>
      <link>https://cuilan.github.io/post/java/navigablemap-source-analysis/</link>
      <pubDate>Wed, 28 Aug 2019 17:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/navigablemap-source-analysis/</guid>
      <description>java.util.NavigableMap 接口直接继承自 java.util.SortedMap 接口。 NavigableMap接口继承关系 一、NavigableMap特点或规范 NavigableMap 使用可导航的方法扩展了 SortedMap</description>
    </item>
    
    <item>
      <title>SortedMap接口源码分析</title>
      <link>https://cuilan.github.io/post/java/sortedmap-source-analysis/</link>
      <pubDate>Tue, 27 Aug 2019 23:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/sortedmap-source-analysis/</guid>
      <description>java.util.SortedMap 接口直接继承自 java.util.Map 接口。 SortedMap接口继承关系 一、SortedMap特点或规范 SortedMap 在 Map 的基础上进一步提供其 key 的总排序。 SortedMap 默认是根据其 key</description>
    </item>
    
    <item>
      <title>Map接口源码分析</title>
      <link>https://cuilan.github.io/post/java/map-source-analysis/</link>
      <pubDate>Wed, 21 Aug 2019 15:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/map-source-analysis/</guid>
      <description>java.util.Map 接口是双列集合的顶级接口。 一、Map特点或规范 双列集合，由 key 映射 value 的对象。 Map 不能包含重复的 key，且每个 key 只能映射一个 value。 Map 接口提</description>
    </item>
    
    <item>
      <title>AbstractQueue源码分析</title>
      <link>https://cuilan.github.io/post/java/abstractqueue-source-analysis/</link>
      <pubDate>Wed, 21 Aug 2019 11:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/abstractqueue-source-analysis/</guid>
      <description>java.util.AbstractQueue 类继承自 java.util.AbstractCollection 抽象类，实现了 java.util.Queue 接口。 AbstractQueue继承关系 一、AbstractQueue特点或规范 AbstractQueue 类提供 队列Queue 操作的基础</description>
    </item>
    
    <item>
      <title>TreeSet源码分析</title>
      <link>https://cuilan.github.io/post/java/treeset-source-analysis/</link>
      <pubDate>Tue, 20 Aug 2019 15:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/treeset-source-analysis/</guid>
      <description>java.util.TreeSet 类继承自 java.util.AbstractSet 抽象类，实现了 java.util.NavigableSet、java.lang.Cloneable、java.io.Serial</description>
    </item>
    
    <item>
      <title>LinkedHashSet源码分析</title>
      <link>https://cuilan.github.io/post/java/linkedhashset-source-analysis/</link>
      <pubDate>Mon, 19 Aug 2019 16:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/linkedhashset-source-analysis/</guid>
      <description>java.util.LinkedHashSet 类继承自 java.util.HashSet 抽象类，实现了 java.util.Set、java.lang.Cloneable、java.io.Serializable 接口。</description>
    </item>
    
    <item>
      <title>HashSet源码分析</title>
      <link>https://cuilan.github.io/post/java/hashset-source-analysis/</link>
      <pubDate>Mon, 19 Aug 2019 10:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/hashset-source-analysis/</guid>
      <description>java.util.HashSet 类继承自 java.util.AbstractSet 抽象类，实现了 java.util.Set、java.lang.Cloneable、java.io.Serializable 接口。</description>
    </item>
    
    <item>
      <title>AbstractSet源码分析</title>
      <link>https://cuilan.github.io/post/java/abstractset-source-analysis/</link>
      <pubDate>Fri, 16 Aug 2019 12:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/abstractset-source-analysis/</guid>
      <description>java.util.AbstractSet 抽象类继承自 java.util.AbstractCollection 抽象类，实现了 java.util.Set 接口。 AbstractSet继承关系 一、AbstractSet特点或规范 AbstractSet 类提供了 Set 接口的基础实现，以最大限</description>
    </item>
    
    <item>
      <title>AbstractSequentialList源码分析</title>
      <link>https://cuilan.github.io/post/java/abstractsequentiallist-source-analysis/</link>
      <pubDate>Fri, 09 Aug 2019 12:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/abstractsequentiallist-source-analysis/</guid>
      <description>java.util.AbstractSequentialList 抽象类继承自 java.util.AbstractList 抽象类。 AbstractSequentialList继承关系 一、AbstractSequentialList特点或规范 此类以</description>
    </item>
    
    <item>
      <title>Deque接口源码分析</title>
      <link>https://cuilan.github.io/post/java/deque-source-analysis/</link>
      <pubDate>Tue, 06 Aug 2019 12:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/deque-source-analysis/</guid>
      <description>java.util.Deque 接口直接继承自 java.util.Queue 接口。 Deque接口继承关系 一、Deque接口特点或规范 Deque 是线性集合，最大的特点是支持 两端插入、移除元素。Deque 是 &amp;ldquo;double ended</description>
    </item>
    
    <item>
      <title>Queue接口源码分析</title>
      <link>https://cuilan.github.io/post/java/queue-source-analysis/</link>
      <pubDate>Mon, 05 Aug 2019 18:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/queue-source-analysis/</guid>
      <description>java.util.Queue 接口直接继承自 java.util.Collection 接口。 Queue接口继承关系 一、Queue接口特点或规范 除了基本的 Collection 功能外，队列还提供额外的 插入，提取 和 检查 三组操作。其中</description>
    </item>
    
    <item>
      <title>NavigableSet接口源码分析</title>
      <link>https://cuilan.github.io/post/java/navigableset-source-analysis/</link>
      <pubDate>Thu, 01 Aug 2019 18:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/navigableset-source-analysis/</guid>
      <description>java.util.NavigableSet 接口直接继承自 java.util.SortedSet 接口。 NavigableSet接口继承关系 一、NavigableSet接口特点或规范 java.util.NavigableSet 接口在 java.util.SortedSet 基础上增加了导航功能，使用导</description>
    </item>
    
    <item>
      <title>SortedSet接口源码分析</title>
      <link>https://cuilan.github.io/post/java/sortedset-source-analysis/</link>
      <pubDate>Tue, 30 Jul 2019 23:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/sortedset-source-analysis/</guid>
      <description>java.util.SortedSet 接口直接继承自 java.util.Set 接口。 SortedSet接口继承关系 一、SortedSet接口特点或规范 实现规范 在 java.util.Set 基础上进一步提供其元素的总排序。元素按</description>
    </item>
    
    <item>
      <title>AbstractList源码分析</title>
      <link>https://cuilan.github.io/post/java/abstractlist-source-analysis/</link>
      <pubDate>Wed, 24 Jul 2019 10:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/abstractlist-source-analysis/</guid>
      <description>java.util.AbstractList 抽象类继承了 java.util.AbstractCollection 类，实现了 java.util.List 接口。 AbstractList继承关系 一、AbstractList类继承规范 随机访问性与顺序访问性规范 AbstractList 类提供了</description>
    </item>
    
    <item>
      <title>Set接口源码分析</title>
      <link>https://cuilan.github.io/post/java/set-source-analysis/</link>
      <pubDate>Thu, 18 Jul 2019 15:55:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/set-source-analysis/</guid>
      <description>java.util.Set 接口直接继承自 java.util.Collection 接口。 Set接口继承关系 一、Set接口特点或规范 不包含重复元素。至多一个 null 元素。数学意义的集合。 全部方法都继承自 java.util.Collection 接口。 子</description>
    </item>
    
    <item>
      <title>AbstractCollection源码分析</title>
      <link>https://cuilan.github.io/post/java/abstractcollection-source-analysis/</link>
      <pubDate>Thu, 18 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/abstractcollection-source-analysis/</guid>
      <description>java.util.AbstractCollection 抽象类实现了 java.util.Collection 接口。 AbstractCollection继承关系 一、AbstractCollection类继承规范 AbstractCollection 抽象类提供了 Collection 接口的骨</description>
    </item>
    
    <item>
      <title>List接口源码分析</title>
      <link>https://cuilan.github.io/post/java/list-source-analysis/</link>
      <pubDate>Wed, 17 Jul 2019 15:34:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/list-source-analysis/</guid>
      <description>java.util.List 接口直接继承自 java.util.Collection 接口，在 Collection 接口的功能之上添加了 List 功能特有的接口规范。 List接口继承关系 一、List接口特点 有序集合。 该接口的子类实现可以</description>
    </item>
    
    <item>
      <title>Collection接口源码分析</title>
      <link>https://cuilan.github.io/post/java/collection-source-analysis/</link>
      <pubDate>Mon, 15 Jul 2019 11:02:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/collection-source-analysis/</guid>
      <description>java.util.Collection 接口是单列集合层次结构中的 根接口。集合表示 一组对象，称为其 元素。其有些子类集合允许重复元素，有些其他集合则不允许。有些是有序的，有些是无序</description>
    </item>
    
    <item>
      <title>Iterable接口源码分析</title>
      <link>https://cuilan.github.io/post/java/iterable-source-analysis/</link>
      <pubDate>Fri, 12 Jul 2019 10:18:22 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/iterable-source-analysis/</guid>
      <description>实现此接口的对象成为“for-each loop”语句的目标，即具有可迭代功能。 Iterable 接口在 java.lang 包下，java.util.Collection 接口实</description>
    </item>
    
    <item>
      <title>Java集合框架源码分析</title>
      <link>https://cuilan.github.io/post/java/javacollectionsframework/</link>
      <pubDate>Fri, 12 Jul 2019 16:31:00 +0800</pubDate>
      
      <guid>https://cuilan.github.io/post/java/javacollectionsframework/</guid>
      <description>一、接口 单列集合接口 java.lang.Iterable java.util.Collection java.util.List java.util.Set java.util.SortedSet java.util.NavigableSet java.util.Queue java.util.Deque 双列集合接口 java.util.Map java.util.SortedMap java.util.NavigableMap 二、抽象类/类，继承关系，实现接口 单列集合类 java.util.AbstractCollection java.util.AbstractList java.util.ArrayList java.util.AbstractSequentialList java.util.LinkedList java.util.Vector java.util.Stack java.util.AbstractSet java.util.HashSet java.util.LinkedHashSet java.util.TreeSet java.util.AbstractQueue java.util.ArrayDeque 双列集合类 java.util.AbstractMap java.util.HashMap java.util.LinkedHashMap</description>
    </item>
    
    <item>
      <title>Java中的锁（Lock接口）</title>
      <link>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E4%B8%AD%E7%9A%84%E9%94%81%E4%B8%80/</link>
      <pubDate>Tue, 09 Jul 2019 19:39:01 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E4%B8%AD%E7%9A%84%E9%94%81%E4%B8%80/</guid>
      <description>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，如：</description>
    </item>
    
    <item>
      <title>Java内存模型四（volatile内存语义）</title>
      <link>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9B%9B/</link>
      <pubDate>Thu, 30 May 2019 23:35:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9B%9B/</guid>
      <description>1、volatile的特性 可见性：对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。 原子性：对任意单个 volatile 变量的读/写具有原子性</description>
    </item>
    
    <item>
      <title>Java内存模型三（顺序一致性）</title>
      <link>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%89/</link>
      <pubDate>Wed, 29 May 2019 23:37:00 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%89/</guid>
      <description>顺序一致性内存模型 是一个理论参考模型。处理器的内存模型 和 编程语言的内存模型 都会以其作为参考。 1、数据竞争与顺序一致性 Java内存模型规范对 数</description>
    </item>
    
    <item>
      <title>Java内存模型二（重排序）</title>
      <link>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BA%8C/</link>
      <pubDate>Mon, 27 May 2019 23:33:46 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BA%8C/</guid>
      <description>重排序：指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。 1、数据依赖性 如果两个操作访问同一个变量，且这两个操作中有一个为</description>
    </item>
    
    <item>
      <title>Java内存模型一（基础）</title>
      <link>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%80/</link>
      <pubDate>Wed, 22 May 2019 22:26:01 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%80/</guid>
      <description>Java内存模型的基础：主要介绍内存模型相关的基本概念 Java内存模型中的顺序一致性：主要介绍 重排序 与 顺序一致性内存模型 同步原语：主要介绍3</description>
    </item>
    
    <item>
      <title>Java并发机制的底层实现原理（原子操作）</title>
      <link>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%89/</link>
      <pubDate>Mon, 01 Apr 2019 22:29:11 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%89/</guid>
      <description>原子操作：不可被中断的一个或一系列操作。 一、处理器如何实现原子操作 使用总线锁保证原子性 第一个机制是通过总线锁保证原子性。如果多个处理器同时对</description>
    </item>
    
    <item>
      <title>Java并发机制的底层实现原理（synchronized）</title>
      <link>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BA%8C/</link>
      <pubDate>Thu, 21 Mar 2019 00:16:03 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BA%8C/</guid>
      <description>synchronized 一般称之为重量级锁，在Java1.6中对 synchronized 进行了各种优化，在有些情况下它并不那么重了。 利用synchronized实现同步的基础 在Java</description>
    </item>
    
    <item>
      <title>Java对象头详解</title>
      <link>https://cuilan.github.io/post/java/java-object-head/</link>
      <pubDate>Fri, 15 Mar 2019 11:23:51 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/java-object-head/</guid>
      <description>由于Java面向对象的思想，在JVM中需要大量存储对象，存储时为了实现一些额外的功能，需要在对象中添加一些标记字段用于增强对象功能，这些标记</description>
    </item>
    
    <item>
      <title>Java并发机制的底层实现原理（volatile）</title>
      <link>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%80/</link>
      <pubDate>Tue, 05 Mar 2019 23:20:27 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%80/</guid>
      <description>Java中所使用的并发机制依赖于JVM的实现和CPU的指令。在多线程并发编程中 synchronized 和 volatile 都扮演着重要的角色。 volatile的应用 volatile 是轻量级的 s</description>
    </item>
    
    <item>
      <title>Java并发解决方案</title>
      <link>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Mon, 04 Mar 2019 23:11:08 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description>Java并发编程的缺陷 上下文切换带来的CPU开销 死锁 物理硬件的限制 软件资源的限制 为什么需要并发？ 并发其实是一种解耦合的策略，这种策略帮助我们</description>
    </item>
    
    <item>
      <title>二、随机事件间的运算律</title>
      <link>https://cuilan.github.io/post/%E6%9D%82%E9%A1%B9/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E4%BA%8C%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E9%97%B4%E7%9A%84%E8%BF%90%E7%AE%97%E5%BE%8B/</link>
      <pubDate>Wed, 09 Jan 2019 00:34:59 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/%E6%9D%82%E9%A1%B9/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E4%BA%8C%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E9%97%B4%E7%9A%84%E8%BF%90%E7%AE%97%E5%BE%8B/</guid>
      <description>&lt;h2 id=&#34;基本定律&#34;&gt;基本定律：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;幂等律&lt;/strong&gt;：A∪A = A，A∩A = A
&lt;strong&gt;交换律&lt;/strong&gt;：A∪B = B∪A，A∩B = B∩A
&lt;strong&gt;结合律&lt;/strong&gt;：(A∪B)∪C = A∪(B∪C)，(A∩B)∩C = A∩(B∩C)
&lt;strong&gt;分配律&lt;/strong&gt;：A∩(B∪C) = (A∩B)∪(A∩C)，A∪(B∩C) = (A∪B)∩(A∪C)&lt;/p&gt;
&lt;h2 id=&#34;demorgan德摩根定律&#34;&gt;De·Morgan（德·摩根）定律：&lt;/h2&gt;
&lt;p&gt;非(A且B) = 非A或非B

  &lt;figure&gt;
    &lt;img src=&#34;https://cuilan.github.io/images/%e6%9d%82%e9%a1%b9/%e4%ba%8c%e3%80%81%e9%9a%8f%e6%9c%ba%e4%ba%8b%e4%bb%b6%e9%97%b4%e7%9a%84%e8%bf%90%e7%ae%97%e5%be%8b/1.png&#34; alt=&#34;德·摩根&#34;&gt;
    &lt;center&gt;&lt;figcaption&gt;德·摩根&lt;/figcaption&gt;&lt;/center&gt;
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;非(A或B) = 非A且非B

  &lt;figure&gt;
    &lt;img src=&#34;https://cuilan.github.io/images/%e6%9d%82%e9%a1%b9/%e4%ba%8c%e3%80%81%e9%9a%8f%e6%9c%ba%e4%ba%8b%e4%bb%b6%e9%97%b4%e7%9a%84%e8%bf%90%e7%ae%97%e5%be%8b/2.png&#34; alt=&#34;德·摩根&#34;&gt;
    &lt;center&gt;&lt;figcaption&gt;德·摩根&lt;/figcaption&gt;&lt;/center&gt;
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
    &lt;img src=&#34;https://cuilan.github.io/images/%e6%9d%82%e9%a1%b9/%e4%ba%8c%e3%80%81%e9%9a%8f%e6%9c%ba%e4%ba%8b%e4%bb%b6%e9%97%b4%e7%9a%84%e8%bf%90%e7%ae%97%e5%be%8b/3.png&#34; alt=&#34;德·摩根&#34;&gt;
    &lt;center&gt;&lt;figcaption&gt;德·摩根&lt;/figcaption&gt;&lt;/center&gt;
  &lt;/figure&gt;

&lt;/p&gt;
&lt;p&gt;
  &lt;figure&gt;
    &lt;img src=&#34;https://cuilan.github.io/images/%e6%9d%82%e9%a1%b9/%e4%ba%8c%e3%80%81%e9%9a%8f%e6%9c%ba%e4%ba%8b%e4%bb%b6%e9%97%b4%e7%9a%84%e8%bf%90%e7%ae%97%e5%be%8b/4.png&#34; alt=&#34;德·摩根&#34;&gt;
    &lt;center&gt;&lt;figcaption&gt;德·摩根&lt;/figcaption&gt;&lt;/center&gt;
  &lt;/figure&gt;

&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一、概率与随机事件</title>
      <link>https://cuilan.github.io/post/%E6%9D%82%E9%A1%B9/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E4%B8%80%E6%A6%82%E7%8E%87%E4%B8%8E%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Mon, 07 Jan 2019 23:36:54 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/%E6%9D%82%E9%A1%B9/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E4%B8%80%E6%A6%82%E7%8E%87%E4%B8%8E%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6/</guid>
      <description>&lt;h2 id=&#34;随机试验experiment&#34;&gt;随机试验（Experiment）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义：对事物的某一特征的观察。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;其典型的例子有：&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;E&lt;!-- raw HTML omitted --&gt;1&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;：抛一枚硬币，观察正面H（Heads）、反面T（Tails）出现的情况。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;E&lt;!-- raw HTML omitted --&gt;2&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;：抛一颗骰子，观察出现的点数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;E&lt;!-- raw HTML omitted --&gt;3&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;：观察某一时间段通过某一路口的车辆数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;E&lt;!-- raw HTML omitted --&gt;4&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;：观察某一电子元件的寿命。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;E&lt;!-- raw HTML omitted --&gt;5&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;：观察某地区一昼夜的最低温度和最高温度。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Nginx高级</title>
      <link>https://cuilan.github.io/post/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/nginx-high/</link>
      <pubDate>Wed, 19 Dec 2018 12:19:23 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/nginx-high/</guid>
      <description>一、Nginx的反向代理 反向代理服务器： Nginx反向代理 优势： 隔离内部服务器，提高安全性。 可以在代理服务器上增加缓存，减少后端服务器的压力</description>
    </item>
    
    <item>
      <title>Nginx基础</title>
      <link>https://cuilan.github.io/post/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/nginx-base/</link>
      <pubDate>Thu, 13 Dec 2018 15:31:24 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/nginx-base/</guid>
      <description>一、什么是 Nginx？ Nginx 是一款性能极高的 HTTP 反向代理服务器，Nginx 官方发布的测试数据显示，支持10000非活动的连接只需2.5M内存的性能</description>
    </item>
    
    <item>
      <title>LinkedList源码分析</title>
      <link>https://cuilan.github.io/post/java/linked-list-source-analysis/</link>
      <pubDate>Thu, 06 Dec 2018 23:10:05 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/linked-list-source-analysis/</guid>
      <description>一、LinkedList简介二、成员分析三、链表实现四、双端队列实现五、队列实现六、栈实现七、列表实现八、迭代器、分割器一、LinkedLi</description>
    </item>
    
    <item>
      <title>ArrayList源码分析</title>
      <link>https://cuilan.github.io/post/java/array-list-source-analysis/</link>
      <pubDate>Thu, 15 Nov 2018 22:26:53 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/java/array-list-source-analysis/</guid>
      <description>ArrayList应该算是日常开发中使用最多的List实现类。 一、ArrayList 的特性 有序 可重复 线程不安全 允许插入 null 值 查询快、增删慢 底层</description>
    </item>
    
    <item>
      <title>七、理解GC日志</title>
      <link>https://cuilan.github.io/post/jvm/jvm-gc-log/</link>
      <pubDate>Thu, 08 Nov 2018 15:13:38 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/jvm/jvm-gc-log/</guid>
      <description>每一种收集器的日志形式都是由它们自身的实现所决定的，换而言之，每个收集器的日志格式都可以不一样。但虚拟机设计者为了方便用户阅读，将各个收集器</description>
    </item>
    
    <item>
      <title>六、垃圾收集器</title>
      <link>https://cuilan.github.io/post/jvm/jvm-garbage-collector/</link>
      <pubDate>Thu, 08 Nov 2018 15:12:57 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/jvm/jvm-garbage-collector/</guid>
      <description>收集算法是内存回收的方法论，而 垃圾收集器就是内存回收的具体实现 。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、</description>
    </item>
    
    <item>
      <title>五、HotSpot的算法实现</title>
      <link>https://cuilan.github.io/post/jvm/jvm-hotspot-algorithm/</link>
      <pubDate>Thu, 08 Nov 2018 14:24:45 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/jvm/jvm-hotspot-algorithm/</guid>
      <description>枚举根节点 以可达性分析中从GC Roots节点找引用链这个操作为例， 可作为GC Roots的节点主要在全局性的引用（如常量或类静态属性）与执行上</description>
    </item>
    
    <item>
      <title>四、垃圾回收算法</title>
      <link>https://cuilan.github.io/post/jvm/jvm-gc-algorithm/</link>
      <pubDate>Thu, 08 Nov 2018 12:14:26 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/jvm/jvm-gc-algorithm/</guid>
      <description>标记-清除算法 最基础的收集算法是“ 标记-清除 ”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段： 首先标记出</description>
    </item>
    
    <item>
      <title>三、垃圾收集器与内存分配策略</title>
      <link>https://cuilan.github.io/post/jvm/jvm-gc-memory-strategy/</link>
      <pubDate>Wed, 07 Nov 2018 17:29:52 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/jvm/jvm-gc-memory-strategy/</guid>
      <description>1、概述 第一门正真使用内存动态分配和垃圾回收技术的语言是Lisp语言。 在Java各内存区域中，程序计数器、虚拟机栈、本地方法区3个区域随线程</description>
    </item>
    
    <item>
      <title>二、HotSpot虚拟机对象模型</title>
      <link>https://cuilan.github.io/post/jvm/jvm-object-model/</link>
      <pubDate>Wed, 07 Nov 2018 16:35:23 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/jvm/jvm-object-model/</guid>
      <description>虚拟机内部细节，各虚拟机厂商的实现略有差异，因此以主流的Oracle HotSpot虚拟机为例分析。 1、对象的创建 Java是一门面向对象的编程</description>
    </item>
    
    <item>
      <title>一、Java内存区域与内存溢出异常</title>
      <link>https://cuilan.github.io/post/jvm/jvm-memory-exceptions/</link>
      <pubDate>Wed, 07 Nov 2018 15:37:29 +0000</pubDate>
      
      <guid>https://cuilan.github.io/post/jvm/jvm-memory-exceptions/</guid>
      <description>1、概述 Java虚拟机自动内存管理机制，不需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄露和内存溢出的问题，由</description>
    </item>
    
  </channel>
</rss>
